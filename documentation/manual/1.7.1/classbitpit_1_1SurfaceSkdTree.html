---
layout: doxygen_header
title: Manual - bitpit::SurfaceSkdTree Class Reference
section: documentation
doxygen-show-titlearea: 0
extra-head-includes:
    - doxygen_extra_head.html
---
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
{% if page.doxygen-show-titlearea == 1 %}
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">bitpit
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
{% endif %}
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>bitpit</b></li><li class="navelem"><a class="el" href="classbitpit_1_1SurfaceSkdTree.html">SurfaceSkdTree</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classbitpit_1_1SurfaceSkdTree-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">bitpit::SurfaceSkdTree Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="classbitpit_1_1SurfaceSkdTree.html" title="The SurfaceSkdTree implements a Bounding Volume Hierarchy tree for surface patches.">SurfaceSkdTree</a> implements a Bounding Volume Hierarchy tree for surface patches.  
 <a href="classbitpit_1_1SurfaceSkdTree.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for bitpit::SurfaceSkdTree:</div>
<div class="dyncontent">
<div class="center"><img src="classbitpit_1_1SurfaceSkdTree__inherit__graph.png" border="0" usemap="#abitpit_1_1SurfaceSkdTree_inherit__map" alt="Inheritance graph"/></div>
<map name="abitpit_1_1SurfaceSkdTree_inherit__map" id="abitpit_1_1SurfaceSkdTree_inherit__map">
<area shape="rect" title="The SurfaceSkdTree implements a Bounding Volume Hierarchy tree for surface patches." alt="" coords="5,80,156,107"/>
<area shape="rect" href="classbitpit_1_1PatchSkdTree.html" title="PatchSkdTree is the class that implements a spatial kd&#45;tree (skd&#45;tree) a bitpit patch." alt="" coords="11,5,150,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for bitpit::SurfaceSkdTree:</div>
<div class="dyncontent">
<div class="center"><img src="classbitpit_1_1SurfaceSkdTree__coll__graph.png" border="0" usemap="#abitpit_1_1SurfaceSkdTree_coll__map" alt="Collaboration graph"/></div>
<map name="abitpit_1_1SurfaceSkdTree_coll__map" id="abitpit_1_1SurfaceSkdTree_coll__map">
<area shape="rect" title="The SurfaceSkdTree implements a Bounding Volume Hierarchy tree for surface patches." alt="" coords="2805,185,2956,211"/>
<area shape="rect" href="classbitpit_1_1PatchSkdTree.html" title="PatchSkdTree is the class that implements a spatial kd&#45;tree (skd&#45;tree) a bitpit patch." alt="" coords="2617,185,2756,211"/>
<area shape="rect" href="structbitpit_1_1SkdPatchInfo.html" title="The SkdPatchInfo class allows to store patch information needed for the construction and the utilizat..." alt="" coords="2356,185,2492,211"/>
<area shape="rect" href="classbitpit_1_1PatchKernel.html" title="The PatchKernel class provides an interface for defining patches." alt="" coords="2127,185,2253,211"/>
<area shape="rect" href="classbitpit_1_1VTKBaseStreamer.html" title="The base class to be used to derive VTK streamers form." alt="" coords="1831,98,1997,125"/>
<area shape="rect" href="classbitpit_1_1PiercedVector.html" title=" " alt="" coords="1845,149,1983,191"/>
<area shape="rect" href="classbitpit_1_1BasePiercedVector.html" title="Base class for pierced vectors." alt="" coords="1303,335,1471,362"/>
<area shape="rect" href="classbitpit_1_1PiercedVector.html" title="Metafunction for generating a pierced vector." alt="" coords="1528,221,1667,263"/>
<area shape="rect" href="classbitpit_1_1PiercedVector.html" title=" " alt="" coords="1845,345,1983,387"/>
<area shape="rect" href="classbitpit_1_1PiercedVector.html" title=" " alt="" coords="1845,215,1983,256"/>
<area shape="rect" href="classbitpit_1_1PiercedVectorKernel.html" title=" " alt="" coords="1300,97,1475,139"/>
<area shape="rect" href="classbitpit_1_1BasePiercedVectorKernel.html" title="Base class for pierced vector kernels." alt="" coords="747,5,915,47"/>
<area shape="rect" href="classbitpit_1_1PiercedVectorKernel.html" title="Kernel of the pierced vector." alt="" coords="968,41,1143,83"/>
<area shape="rect" href="classbitpit_1_1PiercedKernel.html" title=" " alt="" coords="762,77,899,119"/>
<area shape="rect" href="classbitpit_1_1BasePiercedKernel.html" title="Base class for the pierced kernel." alt="" coords="230,95,397,122"/>
<area shape="rect" href="classbitpit_1_1PiercedKernel.html" title="Metafunction for generating a pierced kernel." alt="" coords="455,129,593,171"/>
<area shape="rect" href="classbitpit_1_1PiercedSyncMaster.html" title="Base class for defining an object that acts like a master in pierced synchronization." alt="" coords="5,95,176,122"/>
<area shape="rect" href="classbitpit_1_1PiercedVectorStorage.html" title="Kernel of the pierced vector." alt="" coords="964,273,1147,315"/>
<area shape="rect" href="classbitpit_1_1PiercedVectorStorage.html" title=" " alt="" coords="1296,201,1479,243"/>
<area shape="rect" href="classbitpit_1_1BasePiercedVectorStorage.html" title="Base class for pierced vector kernels." alt="" coords="747,171,915,212"/>
<area shape="rect" href="classbitpit_1_1PiercedStorage.html" title=" " alt="" coords="757,244,904,285"/>
<area shape="rect" href="classbitpit_1_1BasePiercedStorage.html" title="Base class for the pierced storages." alt="" coords="225,231,401,258"/>
<area shape="rect" href="classbitpit_1_1PiercedStorage.html" title="Metafunction for generating a pierced storage." alt="" coords="451,260,597,301"/>
<area shape="rect" href="classbitpit_1_1PiercedSyncSlave.html" title="Base class for defining an object that acts like a slave in pierced synchronization." alt="" coords="9,231,172,258"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a967e91a7056c3d6680f177b64c99a735"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbitpit_1_1SurfaceSkdTree.html#a967e91a7056c3d6680f177b64c99a735">SurfaceSkdTree</a> (const <a class="el" href="classbitpit_1_1SurfaceKernel.html">SurfaceKernel</a> *patch, bool interorOnly=false)</td></tr>
<tr class="separator:a967e91a7056c3d6680f177b64c99a735"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a817142550685f5dd74f3eb74069f7971"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbitpit_1_1SurfaceSkdTree.html#a817142550685f5dd74f3eb74069f7971">clear</a> (bool release)</td></tr>
<tr class="separator:a817142550685f5dd74f3eb74069f7971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa95b4a2b1541c9f9e374bfa445f0d26"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbitpit_1_1SurfaceSkdTree.html#aaa95b4a2b1541c9f9e374bfa445f0d26">evalPointDistance</a> (const std::array&lt; double, 3 &gt; &amp;point) const</td></tr>
<tr class="separator:aaa95b4a2b1541c9f9e374bfa445f0d26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4945ca24050f52d8ea9f923fb0a7bc45"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbitpit_1_1SurfaceSkdTree.html#a4945ca24050f52d8ea9f923fb0a7bc45">evalPointDistance</a> (const std::array&lt; double, 3 &gt; &amp;point, double maxDistance) const</td></tr>
<tr class="separator:a4945ca24050f52d8ea9f923fb0a7bc45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a060282d1075e54c1548f82f5cae87dd4"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbitpit_1_1SurfaceSkdTree.html#a060282d1075e54c1548f82f5cae87dd4">evalPointDistance</a> (const std::array&lt; double, 3 &gt; &amp;point, double maxDistance, bool interorOnly) const</td></tr>
<tr class="separator:a060282d1075e54c1548f82f5cae87dd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1b86dfade675ed3b4b082595045e24a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbitpit_1_1SurfaceSkdTree.html#ae1b86dfade675ed3b4b082595045e24a">evalPointDistance</a> (int nPoints, const std::array&lt; double, 3 &gt; *points, const double *maxDistances, bool interorOnly, double *distances) const</td></tr>
<tr class="separator:ae1b86dfade675ed3b4b082595045e24a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9409b7ce8cb0921798cb1b509f14e0e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbitpit_1_1SurfaceSkdTree.html#aa9409b7ce8cb0921798cb1b509f14e0e">evalPointDistance</a> (int nPoints, const std::array&lt; double, 3 &gt; *points, const double *maxDistances, double *distances) const</td></tr>
<tr class="separator:aa9409b7ce8cb0921798cb1b509f14e0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5116f4775a11241f4553936f565aa0f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbitpit_1_1SurfaceSkdTree.html#a5116f4775a11241f4553936f565aa0f5">evalPointDistance</a> (int nPoints, const std::array&lt; double, 3 &gt; *points, double *distances) const</td></tr>
<tr class="separator:a5116f4775a11241f4553936f565aa0f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a553e4ae9dc047c42db26d35cca21cb16"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbitpit_1_1SurfaceSkdTree.html#a553e4ae9dc047c42db26d35cca21cb16">evalPointDistance</a> (int nPoints, const std::array&lt; double, 3 &gt; *points, double maxDistance, double *distances) const</td></tr>
<tr class="separator:a553e4ae9dc047c42db26d35cca21cb16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e0f473eb7baecd3b182918d1e5f48dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbitpit_1_1SurfaceSkdTree.html#a7e0f473eb7baecd3b182918d1e5f48dc">evalPointGlobalDistance</a> (int nPoints, const std::array&lt; double, 3 &gt; *points, const double *maxDistances, double *distances) const</td></tr>
<tr class="separator:a7e0f473eb7baecd3b182918d1e5f48dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a590eb60f735139af606363c1ded4712d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbitpit_1_1SurfaceSkdTree.html#a590eb60f735139af606363c1ded4712d">evalPointGlobalDistance</a> (int nPoints, const std::array&lt; double, 3 &gt; *points, double *distances) const</td></tr>
<tr class="separator:a590eb60f735139af606363c1ded4712d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18f945c05bc3e2a65406515f93e13799"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbitpit_1_1SurfaceSkdTree.html#a18f945c05bc3e2a65406515f93e13799">evalPointGlobalDistance</a> (int nPoints, const std::array&lt; double, 3 &gt; *points, double maxDistance, double *distances) const</td></tr>
<tr class="separator:a18f945c05bc3e2a65406515f93e13799"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd79b580c6d72239dece725aec8cf59a"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbitpit_1_1SurfaceSkdTree.html#abd79b580c6d72239dece725aec8cf59a">findPointClosestCell</a> (const std::array&lt; double, 3 &gt; &amp;point, double maxDistance, bool interorOnly, long *id, double *distance) const</td></tr>
<tr class="separator:abd79b580c6d72239dece725aec8cf59a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d1595b9306c62623e673e1dc8814afa"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbitpit_1_1SurfaceSkdTree.html#a9d1595b9306c62623e673e1dc8814afa">findPointClosestCell</a> (const std::array&lt; double, 3 &gt; &amp;point, double maxDistance, long *id, double *distance) const</td></tr>
<tr class="separator:a9d1595b9306c62623e673e1dc8814afa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4bc8abeeacddb4edbb887667f25307b"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbitpit_1_1SurfaceSkdTree.html#ac4bc8abeeacddb4edbb887667f25307b">findPointClosestCell</a> (const std::array&lt; double, 3 &gt; &amp;point, long *id, double *distance) const</td></tr>
<tr class="separator:ac4bc8abeeacddb4edbb887667f25307b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d3e3e12393c44a907b0cb8e10ac6a18"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbitpit_1_1SurfaceSkdTree.html#a7d3e3e12393c44a907b0cb8e10ac6a18">findPointClosestCell</a> (int nPoints, const std::array&lt; double, 3 &gt; *points, const double *maxDistances, bool interorOnly, long *ids, double *distances) const</td></tr>
<tr class="separator:a7d3e3e12393c44a907b0cb8e10ac6a18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a02f03e46cc604a5313c543ae38bad8"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbitpit_1_1SurfaceSkdTree.html#a3a02f03e46cc604a5313c543ae38bad8">findPointClosestCell</a> (int nPoints, const std::array&lt; double, 3 &gt; *points, const double *maxDistances, long *ids, double *distances) const</td></tr>
<tr class="separator:a3a02f03e46cc604a5313c543ae38bad8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33c9fc0083f5de063378d6801b9ffbc3"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbitpit_1_1SurfaceSkdTree.html#a33c9fc0083f5de063378d6801b9ffbc3">findPointClosestCell</a> (int nPoints, const std::array&lt; double, 3 &gt; *points, double maxDistance, long *ids, double *distances) const</td></tr>
<tr class="separator:a33c9fc0083f5de063378d6801b9ffbc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cb25f4c2511d8383e7c336c5ed7f3d2"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbitpit_1_1SurfaceSkdTree.html#a3cb25f4c2511d8383e7c336c5ed7f3d2">findPointClosestCell</a> (int nPoints, const std::array&lt; double, 3 &gt; *points, long *ids, double *distances) const</td></tr>
<tr class="separator:a3cb25f4c2511d8383e7c336c5ed7f3d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17ec12f9a715d4b60858222faa8e6bd3"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbitpit_1_1SurfaceSkdTree.html#a17ec12f9a715d4b60858222faa8e6bd3">findPointClosestGlobalCell</a> (int nPoints, const std::array&lt; double, 3 &gt; *points, const double *maxDistances, long *ids, int *ranks, double *distances) const</td></tr>
<tr class="separator:a17ec12f9a715d4b60858222faa8e6bd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bc9734da37cfb051f2034f73d51535c"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbitpit_1_1SurfaceSkdTree.html#a4bc9734da37cfb051f2034f73d51535c">findPointClosestGlobalCell</a> (int nPoints, const std::array&lt; double, 3 &gt; *points, double maxDistance, long *ids, int *ranks, double *distances) const</td></tr>
<tr class="separator:a4bc9734da37cfb051f2034f73d51535c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a456a89a62a4e3f18fb8eff4b880a3a3d"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbitpit_1_1SurfaceSkdTree.html#a456a89a62a4e3f18fb8eff4b880a3a3d">findPointClosestGlobalCell</a> (int nPoints, const std::array&lt; double, 3 &gt; *points, long *ids, int *ranks, double *distances) const</td></tr>
<tr class="separator:a456a89a62a4e3f18fb8eff4b880a3a3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classbitpit_1_1PatchSkdTree"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classbitpit_1_1PatchSkdTree')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classbitpit_1_1PatchSkdTree.html">bitpit::PatchSkdTree</a></td></tr>
<tr class="memitem:aa54387e351eb08bcc15ba277b0e7f550 inherit pub_methods_classbitpit_1_1PatchSkdTree"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbitpit_1_1PatchSkdTree.html#aa54387e351eb08bcc15ba277b0e7f550">build</a> (std::size_t leaftThreshold=1, bool squeezeStorage=false)</td></tr>
<tr class="separator:aa54387e351eb08bcc15ba277b0e7f550 inherit pub_methods_classbitpit_1_1PatchSkdTree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8b93308ea98981bd556bf9e57e024f6 inherit pub_methods_classbitpit_1_1PatchSkdTree"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbitpit_1_1PatchSkdTree.html#ab8b93308ea98981bd556bf9e57e024f6">clear</a> (bool release=false)</td></tr>
<tr class="separator:ab8b93308ea98981bd556bf9e57e024f6 inherit pub_methods_classbitpit_1_1PatchSkdTree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b7bb47e8eab7b60b1fe4f905a93dc62 inherit pub_methods_classbitpit_1_1PatchSkdTree"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbitpit_1_1PatchSkdTree.html#a1b7bb47e8eab7b60b1fe4f905a93dc62">evalMaxDepth</a> (std::size_t rootId=0) const</td></tr>
<tr class="separator:a1b7bb47e8eab7b60b1fe4f905a93dc62 inherit pub_methods_classbitpit_1_1PatchSkdTree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a502965ba193dd35e52099015feb62610 inherit pub_methods_classbitpit_1_1PatchSkdTree"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbitpit_1_1PatchSkdTree.html#a502965ba193dd35e52099015feb62610">getLeafCount</a> () const</td></tr>
<tr class="separator:a502965ba193dd35e52099015feb62610 inherit pub_methods_classbitpit_1_1PatchSkdTree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e99669b9750f48b9af825916da436f9 inherit pub_methods_classbitpit_1_1PatchSkdTree"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbitpit_1_1PatchSkdTree.html#a2e99669b9750f48b9af825916da436f9">getLeafMaxCellCount</a> () const</td></tr>
<tr class="separator:a2e99669b9750f48b9af825916da436f9 inherit pub_methods_classbitpit_1_1PatchSkdTree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24780d7ce1edb52f8c45731f8d207b39 inherit pub_methods_classbitpit_1_1PatchSkdTree"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbitpit_1_1PatchSkdTree.html#a24780d7ce1edb52f8c45731f8d207b39">getLeafMinCellCount</a> () const</td></tr>
<tr class="separator:a24780d7ce1edb52f8c45731f8d207b39 inherit pub_methods_classbitpit_1_1PatchSkdTree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a930ff5643db684335e7215ccd0c834f2 inherit pub_methods_classbitpit_1_1PatchSkdTree"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classbitpit_1_1SkdNode.html">SkdNode</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbitpit_1_1PatchSkdTree.html#a930ff5643db684335e7215ccd0c834f2">getNode</a> (std::size_t nodeId) const</td></tr>
<tr class="separator:a930ff5643db684335e7215ccd0c834f2 inherit pub_methods_classbitpit_1_1PatchSkdTree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0623d9c4545904ec9efd3a44ca4e7d3 inherit pub_methods_classbitpit_1_1PatchSkdTree"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbitpit_1_1PatchSkdTree.html#ab0623d9c4545904ec9efd3a44ca4e7d3">getNodeCount</a> () const</td></tr>
<tr class="separator:ab0623d9c4545904ec9efd3a44ca4e7d3 inherit pub_methods_classbitpit_1_1PatchSkdTree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d53c7bd09893a768eded2a0c5d7c342 inherit pub_methods_classbitpit_1_1PatchSkdTree"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classbitpit_1_1SkdBox.html">SkdBox</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbitpit_1_1PatchSkdTree.html#a1d53c7bd09893a768eded2a0c5d7c342">getPartitionBox</a> (int rank) const</td></tr>
<tr class="separator:a1d53c7bd09893a768eded2a0c5d7c342 inherit pub_methods_classbitpit_1_1PatchSkdTree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc4eba0df970f5dc84d61ded06b7239c inherit pub_methods_classbitpit_1_1PatchSkdTree"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classbitpit_1_1PatchKernel.html">PatchKernel</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbitpit_1_1PatchSkdTree.html#afc4eba0df970f5dc84d61ded06b7239c">getPatch</a> () const</td></tr>
<tr class="separator:afc4eba0df970f5dc84d61ded06b7239c inherit pub_methods_classbitpit_1_1PatchSkdTree"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_methods_classbitpit_1_1PatchSkdTree"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classbitpit_1_1PatchSkdTree')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classbitpit_1_1PatchSkdTree.html">bitpit::PatchSkdTree</a></td></tr>
<tr class="memitem:ac68445b0f9cc912df621bf7ee3f00170 inherit pro_methods_classbitpit_1_1PatchSkdTree"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbitpit_1_1PatchSkdTree.html#ac68445b0f9cc912df621bf7ee3f00170">PatchSkdTree</a> (const <a class="el" href="classbitpit_1_1PatchKernel.html">PatchKernel</a> *patch, bool interiorCellsOnly=false)</td></tr>
<tr class="separator:ac68445b0f9cc912df621bf7ee3f00170 inherit pro_methods_classbitpit_1_1PatchSkdTree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58e7b7c1b4865de58b850795ae5af108 inherit pro_methods_classbitpit_1_1PatchSkdTree"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbitpit_1_1SkdNode.html">SkdNode</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbitpit_1_1PatchSkdTree.html#a58e7b7c1b4865de58b850795ae5af108">_getNode</a> (std::size_t nodeId)</td></tr>
<tr class="separator:a58e7b7c1b4865de58b850795ae5af108 inherit pro_methods_classbitpit_1_1PatchSkdTree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a438dfcb672749718f243c9c7942762af inherit pro_methods_classbitpit_1_1PatchSkdTree"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbitpit_1_1PatchSkdTree.html#a438dfcb672749718f243c9c7942762af">freeCommunicator</a> ()</td></tr>
<tr class="separator:a438dfcb672749718f243c9c7942762af inherit pro_methods_classbitpit_1_1PatchSkdTree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af03e99ad3e3f1200317d599cd76c5ec9 inherit pro_methods_classbitpit_1_1PatchSkdTree"><td class="memItemLeft" align="right" valign="top">const MPI_Comm &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbitpit_1_1PatchSkdTree.html#af03e99ad3e3f1200317d599cd76c5ec9">getCommunicator</a> () const</td></tr>
<tr class="separator:af03e99ad3e3f1200317d599cd76c5ec9 inherit pro_methods_classbitpit_1_1PatchSkdTree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a095c37070be661ea10dfcaefb90a5ab7 inherit pro_methods_classbitpit_1_1PatchSkdTree"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbitpit_1_1PatchSkdTree.html#a095c37070be661ea10dfcaefb90a5ab7">isCommunicatorSet</a> () const</td></tr>
<tr class="separator:a095c37070be661ea10dfcaefb90a5ab7 inherit pro_methods_classbitpit_1_1PatchSkdTree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ba084c7f538233b6eeaff91e44f8adf inherit pro_methods_classbitpit_1_1PatchSkdTree"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbitpit_1_1PatchSkdTree.html#a4ba084c7f538233b6eeaff91e44f8adf">setCommunicator</a> (MPI_Comm communicator)</td></tr>
<tr class="separator:a4ba084c7f538233b6eeaff91e44f8adf inherit pro_methods_classbitpit_1_1PatchSkdTree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classbitpit_1_1PatchSkdTree"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classbitpit_1_1PatchSkdTree')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classbitpit_1_1PatchSkdTree.html">bitpit::PatchSkdTree</a></td></tr>
<tr class="memitem:a096f9be6ba248122f58e9a838b5eed9d inherit pro_attribs_classbitpit_1_1PatchSkdTree"><td class="memItemLeft" align="right" valign="top"><a id="a096f9be6ba248122f58e9a838b5eed9d"></a>
std::vector&lt; std::size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_cellRawIds</b></td></tr>
<tr class="separator:a096f9be6ba248122f58e9a838b5eed9d inherit pro_attribs_classbitpit_1_1PatchSkdTree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06cb8efa7aa4a78594743775a1c7b7ab inherit pro_attribs_classbitpit_1_1PatchSkdTree"><td class="memItemLeft" align="right" valign="top"><a id="a06cb8efa7aa4a78594743775a1c7b7ab"></a>
MPI_Comm&#160;</td><td class="memItemRight" valign="bottom"><b>m_communicator</b></td></tr>
<tr class="separator:a06cb8efa7aa4a78594743775a1c7b7ab inherit pro_attribs_classbitpit_1_1PatchSkdTree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a2912f534fb257aa3efc8f3ec2c82f9 inherit pro_attribs_classbitpit_1_1PatchSkdTree"><td class="memItemLeft" align="right" valign="top"><a id="a1a2912f534fb257aa3efc8f3ec2c82f9"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>m_interiorCellsOnly</b></td></tr>
<tr class="separator:a1a2912f534fb257aa3efc8f3ec2c82f9 inherit pro_attribs_classbitpit_1_1PatchSkdTree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2336bf63ec0a8696fac1a5d34a18b1c9 inherit pro_attribs_classbitpit_1_1PatchSkdTree"><td class="memItemLeft" align="right" valign="top"><a id="a2336bf63ec0a8696fac1a5d34a18b1c9"></a>
std::size_t&#160;</td><td class="memItemRight" valign="bottom"><b>m_nLeafs</b></td></tr>
<tr class="separator:a2336bf63ec0a8696fac1a5d34a18b1c9 inherit pro_attribs_classbitpit_1_1PatchSkdTree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1762ebaf38e567e42e1e24775d3493b inherit pro_attribs_classbitpit_1_1PatchSkdTree"><td class="memItemLeft" align="right" valign="top"><a id="ab1762ebaf38e567e42e1e24775d3493b"></a>
std::size_t&#160;</td><td class="memItemRight" valign="bottom"><b>m_nMaxLeafCells</b></td></tr>
<tr class="separator:ab1762ebaf38e567e42e1e24775d3493b inherit pro_attribs_classbitpit_1_1PatchSkdTree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd758d949406b15eb4b2b7d7fbad427f inherit pro_attribs_classbitpit_1_1PatchSkdTree"><td class="memItemLeft" align="right" valign="top"><a id="acd758d949406b15eb4b2b7d7fbad427f"></a>
std::size_t&#160;</td><td class="memItemRight" valign="bottom"><b>m_nMinLeafCells</b></td></tr>
<tr class="separator:acd758d949406b15eb4b2b7d7fbad427f inherit pro_attribs_classbitpit_1_1PatchSkdTree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabed7a3e91b685b21ee96fbdd2aeae6a inherit pro_attribs_classbitpit_1_1PatchSkdTree"><td class="memItemLeft" align="right" valign="top"><a id="aabed7a3e91b685b21ee96fbdd2aeae6a"></a>
std::vector&lt; <a class="el" href="classbitpit_1_1SkdNode.html">SkdNode</a>, <a class="el" href="structbitpit_1_1SkdNode_1_1Allocator.html">SkdNode::Allocator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_nodes</b></td></tr>
<tr class="separator:aabed7a3e91b685b21ee96fbdd2aeae6a inherit pro_attribs_classbitpit_1_1PatchSkdTree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada1373b0926a03d16b3de1e92a12e3c0 inherit pro_attribs_classbitpit_1_1PatchSkdTree"><td class="memItemLeft" align="right" valign="top"><a id="ada1373b0926a03d16b3de1e92a12e3c0"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>m_nProcessors</b></td></tr>
<tr class="separator:ada1373b0926a03d16b3de1e92a12e3c0 inherit pro_attribs_classbitpit_1_1PatchSkdTree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10fd1ba8628a482e26e8ea0a814f40b5 inherit pro_attribs_classbitpit_1_1PatchSkdTree"><td class="memItemLeft" align="right" valign="top"><a id="a10fd1ba8628a482e26e8ea0a814f40b5"></a>
std::vector&lt; <a class="el" href="classbitpit_1_1SkdBox.html">SkdBox</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_partitionBoxes</b></td></tr>
<tr class="separator:a10fd1ba8628a482e26e8ea0a814f40b5 inherit pro_attribs_classbitpit_1_1PatchSkdTree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd98f625c964d8de8c0f59f093630dae inherit pro_attribs_classbitpit_1_1PatchSkdTree"><td class="memItemLeft" align="right" valign="top"><a id="abd98f625c964d8de8c0f59f093630dae"></a>
<a class="el" href="structbitpit_1_1SkdPatchInfo.html">SkdPatchInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_patchInfo</b></td></tr>
<tr class="separator:abd98f625c964d8de8c0f59f093630dae inherit pro_attribs_classbitpit_1_1PatchSkdTree"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a908cc891a6234debf8fa45c2e0ce0266 inherit pro_attribs_classbitpit_1_1PatchSkdTree"><td class="memItemLeft" align="right" valign="top"><a id="a908cc891a6234debf8fa45c2e0ce0266"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>m_rank</b></td></tr>
<tr class="separator:a908cc891a6234debf8fa45c2e0ce0266 inherit pro_attribs_classbitpit_1_1PatchSkdTree"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="classbitpit_1_1SurfaceSkdTree.html" title="The SurfaceSkdTree implements a Bounding Volume Hierarchy tree for surface patches.">SurfaceSkdTree</a> implements a Bounding Volume Hierarchy tree for surface patches. </p>

<p class="definition">Definition at line <a class="el" href="surface__skd__tree_8hpp_source.html#l00033">33</a> of file <a class="el" href="surface__skd__tree_8hpp_source.html">surface_skd_tree.hpp</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a967e91a7056c3d6680f177b64c99a735"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a967e91a7056c3d6680f177b64c99a735">&#9670;&nbsp;</a></span>SurfaceSkdTree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bitpit::SurfaceSkdTree::SurfaceSkdTree </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbitpit_1_1SurfaceKernel.html">SurfaceKernel</a> *&#160;</td>
          <td class="paramname"><em>patch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>interiorCellsOnly</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">patch</td><td>is the surface patch that will be use to build the tree </td></tr>
    <tr><td class="paramname">interiorCellsOnly</td><td>if set to true, only interior cells will be considered </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="surface__skd__tree_8cpp_source.html#l00042">42</a> of file <a class="el" href="surface__skd__tree_8cpp_source.html">surface_skd_tree.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a817142550685f5dd74f3eb74069f7971"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a817142550685f5dd74f3eb74069f7971">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bitpit::SurfaceSkdTree::clear </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>release</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clear the tree.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">release</td><td>if it's true the memory hold by the tree will be released, otherwise the treewill be cleared but its memory will not be relased </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="surface__skd__tree_8cpp_source.html#l00053">53</a> of file <a class="el" href="surface__skd__tree_8cpp_source.html">surface_skd_tree.cpp</a>.</p>

</div>
</div>
<a id="aaa95b4a2b1541c9f9e374bfa445f0d26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa95b4a2b1541c9f9e374bfa445f0d26">&#9670;&nbsp;</a></span>evalPointDistance() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double bitpit::SurfaceSkdTree::evalPointDistance </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the distance between the specified point and the closest cell contained in the tree. Only cells with a distance less than the specified maximum distance will be considered.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">point</td><td>is the point </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The distance between the specified point and the closest cell contained in the tree. </dd></dl>

<p class="definition">Definition at line <a class="el" href="surface__skd__tree_8cpp_source.html#l00073">73</a> of file <a class="el" href="surface__skd__tree_8cpp_source.html">surface_skd_tree.cpp</a>.</p>

</div>
</div>
<a id="a4945ca24050f52d8ea9f923fb0a7bc45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4945ca24050f52d8ea9f923fb0a7bc45">&#9670;&nbsp;</a></span>evalPointDistance() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double bitpit::SurfaceSkdTree::evalPointDistance </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>maxDistance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the distance between the specified point and the closest cell contained in the tree. Only cells with a distance less than the specified maximum distance will be considered. If all cells contained in the tree are farther than the maximum distance, the function will return the maximum representable distance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">point</td><td>is the point </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxDistance</td><td>all cells whose distance is greater than this parameters will not be considered for the evaluation of the distance </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The distance between the specified point and the closest cell contained in the tree. If all cells contained in the tree are farther than the maximum distance, the function will return the maximum representable distance. </dd></dl>

<p class="definition">Definition at line <a class="el" href="surface__skd__tree_8cpp_source.html#l00094">94</a> of file <a class="el" href="surface__skd__tree_8cpp_source.html">surface_skd_tree.cpp</a>.</p>

</div>
</div>
<a id="a060282d1075e54c1548f82f5cae87dd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a060282d1075e54c1548f82f5cae87dd4">&#9670;&nbsp;</a></span>evalPointDistance() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double bitpit::SurfaceSkdTree::evalPointDistance </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>maxDistance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>interiorCellsOnly</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the distance between the specified point and the closest cell contained in the tree. Only cells with a distance less than the specified maximum distance will be considered. If all cells contained in the tree are farther than the maximum distance, the function will return the maximum representable distance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">point</td><td>is the point </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxDistance</td><td>all cells whose distance is greater than this parameters will not be considered for the evaluation of the distance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">interiorCellsOnly</td><td>if set to true, only interior cells will be considered, it will be possible to consider non-interior cells only if the tree has been instantiated with non-interior cells support enabled </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The distance between the specified point and the closest cell contained in the tree. If all cells contained in the tree are farther than the maximum distance, the function will return the maximum representable distance. </dd></dl>

<p class="definition">Definition at line <a class="el" href="surface__skd__tree_8cpp_source.html#l00118">118</a> of file <a class="el" href="surface__skd__tree_8cpp_source.html">surface_skd_tree.cpp</a>.</p>

</div>
</div>
<a id="ae1b86dfade675ed3b4b082595045e24a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1b86dfade675ed3b4b082595045e24a">&#9670;&nbsp;</a></span>evalPointDistance() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bitpit::SurfaceSkdTree::evalPointDistance </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; *&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>maxDistances</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>interiorCellsOnly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>distances</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the distance between the specified points and the closest cell contained in the tree. Only cells with a distance less than the specified maximum distance will be considered. If all cells contained in the tree are farther than the maximum distance, the function will return the maximum representable distance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nPoints</td><td>is the number of the points </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">points</td><td>are the points coordinates </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxDistances</td><td>are the maximum allowed distances, all cells whose distance is greater than this parameter will not be considered for the evaluation of the distance with respect to the related point </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">interiorCellsOnly</td><td>if set to true, only interior cells will be considered </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">distances</td><td>on output it will contain the distances between the points and closest cells. If all cells contained in the tree are farther than the maximum distance, the related argument will be set to the maximum representable distance. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="surface__skd__tree_8cpp_source.html#l00211">211</a> of file <a class="el" href="surface__skd__tree_8cpp_source.html">surface_skd_tree.cpp</a>.</p>

</div>
</div>
<a id="aa9409b7ce8cb0921798cb1b509f14e0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9409b7ce8cb0921798cb1b509f14e0e">&#9670;&nbsp;</a></span>evalPointDistance() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bitpit::SurfaceSkdTree::evalPointDistance </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; *&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>maxDistances</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>distances</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the distance between the specified points and the closest cell contained in the tree. Only cells with a distance less than the specified maximum distance will be considered. If all cells contained in the tree are farther than the maximum distance, the function will return the maximum representable distance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nPoints</td><td>is the number of the points </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">points</td><td>are the points coordinates </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxDistances</td><td>are the maximum allowed distances, all cells whose distance is greater than this parameter will not be considered for the evaluation of the distance with respect to the related point </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">distances</td><td>on output it will contain the distances between the points and closest cells. If all cells contained in the tree are farther than the maximum distance, the related argument will be set to the maximum representable distance. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="surface__skd__tree_8cpp_source.html#l00186">186</a> of file <a class="el" href="surface__skd__tree_8cpp_source.html">surface_skd_tree.cpp</a>.</p>

</div>
</div>
<a id="a5116f4775a11241f4553936f565aa0f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5116f4775a11241f4553936f565aa0f5">&#9670;&nbsp;</a></span>evalPointDistance() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bitpit::SurfaceSkdTree::evalPointDistance </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; *&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>distances</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the distance between each of the the specified points and the closest cell contained in the tree. Only cells with a distance less than the specified maximum distance will be considered.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nPoints</td><td>is the number of the points </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">points</td><td>are the points coordinates </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">distances</td><td>on output it will contain the distances between the points and closest cells </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="surface__skd__tree_8cpp_source.html#l00138">138</a> of file <a class="el" href="surface__skd__tree_8cpp_source.html">surface_skd_tree.cpp</a>.</p>

</div>
</div>
<a id="a553e4ae9dc047c42db26d35cca21cb16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a553e4ae9dc047c42db26d35cca21cb16">&#9670;&nbsp;</a></span>evalPointDistance() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bitpit::SurfaceSkdTree::evalPointDistance </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; *&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>maxDistance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>distances</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the distance between each of the the specified points and the closest cell contained in the tree. Only cells with a distance less than the specified maximum distance will be considered. If all cells contained in the tree are farther than the maximum distance, the function will return the maximum representable distance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nPoints</td><td>is the number of the points </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">points</td><td>are the points coordinates </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxDistance</td><td>all cells whose distance is greater than this parameters will not be considered for the evaluation of the distance </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">distances</td><td>on output it will contain the distances between the points and closest cells. If all cells contained in the tree are farther than the maximum distance, the related argument will be set to the maximum representable distance. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="surface__skd__tree_8cpp_source.html#l00162">162</a> of file <a class="el" href="surface__skd__tree_8cpp_source.html">surface_skd_tree.cpp</a>.</p>

</div>
</div>
<a id="a7e0f473eb7baecd3b182918d1e5f48dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e0f473eb7baecd3b182918d1e5f48dc">&#9670;&nbsp;</a></span>evalPointGlobalDistance() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bitpit::SurfaceSkdTree::evalPointGlobalDistance </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; *&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>maxDistances</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>distances</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the distance between the specified point, considered distributed on the processes, and the closest cells contained in the tree. Only cells with a distance less than the specified maximum distance will be considered. If all cells contained in the tree are farther than the maximum distance, the function will return the maximum representable distance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nPoints</td><td>is the number of the points </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">points</td><td>are the points coordinates </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxDistances</td><td>are the maximum allowed distances, all cells whose distance is greater than this parameter will not be considered for the evaluation of the distance with respect to the related point </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">distances</td><td>on output it will contain the distances between the points and closest cells. If all cells contained in the tree are farther than the maximum distance, the related argument will be set to the maximum representable distance. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="surface__skd__tree_8cpp_source.html#l00280">280</a> of file <a class="el" href="surface__skd__tree_8cpp_source.html">surface_skd_tree.cpp</a>.</p>

</div>
</div>
<a id="a590eb60f735139af606363c1ded4712d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a590eb60f735139af606363c1ded4712d">&#9670;&nbsp;</a></span>evalPointGlobalDistance() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bitpit::SurfaceSkdTree::evalPointGlobalDistance </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; *&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>distances</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the distance between the specified point, considered distributed on the processes, and the closest cells contained in the tree. Only cells with a distance less than the specified maximum distance will be considered.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nPoints</td><td>is the number of the points </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">points</td><td>are the points coordinates </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">distances</td><td>on output it will contain the distances between the points and closest cells </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="surface__skd__tree_8cpp_source.html#l00230">230</a> of file <a class="el" href="surface__skd__tree_8cpp_source.html">surface_skd_tree.cpp</a>.</p>

</div>
</div>
<a id="a18f945c05bc3e2a65406515f93e13799"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18f945c05bc3e2a65406515f93e13799">&#9670;&nbsp;</a></span>evalPointGlobalDistance() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bitpit::SurfaceSkdTree::evalPointGlobalDistance </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; *&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>maxDistance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>distances</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the distance between the specified point, considered distributed on the processes, and the closest cells contained in the tree. Only cells with a distance less than the specified maximum distance will be considered. If all cells contained in the tree are farther than the maximum distance, the function will return the maximum representable distance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nPoints</td><td>is the number of the points </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">points</td><td>are the points coordinates </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxDistance</td><td>all cells whose distance is greater than this parameters will not be considered for the evaluation of the distance </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">distances</td><td>on output it will contain the distances between the points and closest cells. If all cells contained in the tree are farther than the maximum distance, the related argument will be set to the maximum representable distance. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="surface__skd__tree_8cpp_source.html#l00255">255</a> of file <a class="el" href="surface__skd__tree_8cpp_source.html">surface_skd_tree.cpp</a>.</p>

</div>
</div>
<a id="abd79b580c6d72239dece725aec8cf59a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd79b580c6d72239dece725aec8cf59a">&#9670;&nbsp;</a></span>findPointClosestCell() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long bitpit::SurfaceSkdTree::findPointClosestCell </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>maxDistance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>interiorCellsOnly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long *&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>distance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given the specified point find the closest cell contained in the three and evaluates the distance between that cell and the given point.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">point</td><td>is the point </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxDistance</td><td>all cells whose distance is greater than this parameters will not be considered for the evaluation of the distance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">interiorCellsOnly</td><td>if set to true, only interior cells will be considered, it will be possible to consider non-interior cells only if the tree has been instantiated with non-interior cells support enabled </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">id</td><td>on output it will contain the id of the closest cell. If all cells contained in the tree are farther than the maximum distance, the argument will be set to the null id </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">distance</td><td>on output it will contain the distance between the point and closest cell. If all cells contained in the tree are farther than the maximum distance, the argument will be set to the maximum representable distance </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="surface__skd__tree_8cpp_source.html#l00352">352</a> of file <a class="el" href="surface__skd__tree_8cpp_source.html">surface_skd_tree.cpp</a>.</p>

</div>
</div>
<a id="a9d1595b9306c62623e673e1dc8814afa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d1595b9306c62623e673e1dc8814afa">&#9670;&nbsp;</a></span>findPointClosestCell() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long bitpit::SurfaceSkdTree::findPointClosestCell </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>maxDistance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long *&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>distance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given the specified point find the closest cell contained in the three and evaluates the distance between that cell and the given point.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">point</td><td>is the point </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxDistance</td><td>all cells whose distance is greater than this parameters will not be considered for the evaluation of the distance </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">id</td><td>on output it will contain the id of the closest cell. If all cells contained in the tree are farther than the maximum distance, the argument will be set to the null id </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">distance</td><td>on output it will contain the distance between the point and closest cell. If all cells contained in the tree are farther than the maximum distance, the argument will be set to the maximum representable distance </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="surface__skd__tree_8cpp_source.html#l00326">326</a> of file <a class="el" href="surface__skd__tree_8cpp_source.html">surface_skd_tree.cpp</a>.</p>

</div>
</div>
<a id="ac4bc8abeeacddb4edbb887667f25307b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4bc8abeeacddb4edbb887667f25307b">&#9670;&nbsp;</a></span>findPointClosestCell() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long bitpit::SurfaceSkdTree::findPointClosestCell </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long *&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>distance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given the specified point find the closest cell contained in the three and evaluates the distance between that cell and the given point.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">point</td><td>is the point </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">id</td><td>on output it will contain the id of the cell closest to the point, if the distance between the point and the surface is greater than the specified maximum distance, the id parameter will be set to the null id </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">distance</td><td>on output it will contain the distance between the point and closest cell. If all cells contained in the tree are farther than the maximum distance, the function will return the maximum representable distance. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="surface__skd__tree_8cpp_source.html#l00304">304</a> of file <a class="el" href="surface__skd__tree_8cpp_source.html">surface_skd_tree.cpp</a>.</p>

</div>
</div>
<a id="a7d3e3e12393c44a907b0cb8e10ac6a18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d3e3e12393c44a907b0cb8e10ac6a18">&#9670;&nbsp;</a></span>findPointClosestCell() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long bitpit::SurfaceSkdTree::findPointClosestCell </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; *&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>maxDistances</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>interiorCellsOnly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long *&#160;</td>
          <td class="paramname"><em>ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>distances</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For each of the specified points find the closest cell contained in the three and evaluates the distance between that cell and the point.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nPoints</td><td>is the number of the points </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">points</td><td>are the points coordinates </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxDistances</td><td>are the maximum allowed distances, all cells whose distance is greater than this parameter will not be considered for the evaluation of the distance with respect to the related point </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">interiorCellsOnly</td><td>if set to true, only interior cells will be considered </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ids</td><td>on output it will contain the ids of the cells closest to the points. If all cells contained in the tree are farther from a point than the maximum distance, the related id will be set to the null id </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">distances</td><td>on output it will contain the distances between the points and closest cells. If all cells contained in the tree are farther than the maximum distance, the related argument will be set to the maximum representable distance. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="surface__skd__tree_8cpp_source.html#l00525">525</a> of file <a class="el" href="surface__skd__tree_8cpp_source.html">surface_skd_tree.cpp</a>.</p>

</div>
</div>
<a id="a3a02f03e46cc604a5313c543ae38bad8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a02f03e46cc604a5313c543ae38bad8">&#9670;&nbsp;</a></span>findPointClosestCell() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long bitpit::SurfaceSkdTree::findPointClosestCell </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; *&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>maxDistances</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long *&#160;</td>
          <td class="paramname"><em>ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>distances</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For each of the specified points find the closest cell contained in the three and evaluates the distance between that cell and the point.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nPoints</td><td>is the number of the points </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">points</td><td>are the points coordinates </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxDistances</td><td>are the maximum allowed distances, all cells whose distance is greater than this parameter will not be considered for the evaluation of the distance with respect to the related point </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ids</td><td>on output it will contain the ids of the cells closest to the points. If all cells contained in the tree are farther from a point than the maximum distance, the related id will be set to the null id </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">distances</td><td>on output it will contain the distances between the points and closest cells. If all cells contained in the tree are farther than the maximum distance, the related argument will be set to the maximum representable distance. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="surface__skd__tree_8cpp_source.html#l00501">501</a> of file <a class="el" href="surface__skd__tree_8cpp_source.html">surface_skd_tree.cpp</a>.</p>

</div>
</div>
<a id="a33c9fc0083f5de063378d6801b9ffbc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33c9fc0083f5de063378d6801b9ffbc3">&#9670;&nbsp;</a></span>findPointClosestCell() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long bitpit::SurfaceSkdTree::findPointClosestCell </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; *&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>maxDistance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long *&#160;</td>
          <td class="paramname"><em>ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>distances</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For each of the specified points find the closest cell contained in the three and evaluates the distance between that cell and the point.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nPoints</td><td>is the number of the points </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">points</td><td>are the points coordinates </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxDistance</td><td>all cells whose distance is greater than this parameters will not be considered for the evaluation of the distance </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ids</td><td>on output it will contain the ids of the cells closest to the points. If all cells contained in the tree are farther from a point than the maximum distance, the related id will be set to the null id </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">distances</td><td>on output it will contain the distances between the points and closest cells. If all cells contained in the tree are farther than the maximum distance, the related argument will be set to the maximum representable distance. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="surface__skd__tree_8cpp_source.html#l00474">474</a> of file <a class="el" href="surface__skd__tree_8cpp_source.html">surface_skd_tree.cpp</a>.</p>

</div>
</div>
<a id="a3cb25f4c2511d8383e7c336c5ed7f3d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cb25f4c2511d8383e7c336c5ed7f3d2">&#9670;&nbsp;</a></span>findPointClosestCell() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long bitpit::SurfaceSkdTree::findPointClosestCell </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; *&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long *&#160;</td>
          <td class="paramname"><em>ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>distances</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For each of the specified points find the closest cell contained in the three and evaluates the distance between that cell and the point.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nPoints</td><td>is the number of the points </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">points</td><td>are the points coordinates </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ids</td><td>on output it will contain the ids of the cells closest to the local points </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">distances</td><td>on output it will contain the distances between the points and closest cells </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="surface__skd__tree_8cpp_source.html#l00448">448</a> of file <a class="el" href="surface__skd__tree_8cpp_source.html">surface_skd_tree.cpp</a>.</p>

</div>
</div>
<a id="a17ec12f9a715d4b60858222faa8e6bd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17ec12f9a715d4b60858222faa8e6bd3">&#9670;&nbsp;</a></span>findPointClosestGlobalCell() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long bitpit::SurfaceSkdTree::findPointClosestGlobalCell </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; *&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>maxDistances</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long *&#160;</td>
          <td class="paramname"><em>ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ranks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>distances</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given the specified points, considered distributed on the processes, find the closest cells contained in the tree and evaluates the distance values between those cells and the given points.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nPoints</td><td>is the number of the points </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">points</td><td>are the points coordinates </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxDistances</td><td>are the maximum allowed distances, all cells whose distance is greater than this parameter will not be considered for the evaluation of the distance with respect to the related point </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ids</td><td>on output it will contain the ids of the cells closest to the points. If all cells contained in the tree are farther from a point than the maximum distance, the related id will be set to the null id </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ranks</td><td>on output it will contain the rank indices of the processes owner of the cells closest to the points </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">distances</td><td>on output it will contain the distances between the points and closest cells. If all cells contained in the tree are farther than the maximum distance, the related argument will be set to the maximum representable distance. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="surface__skd__tree_8cpp_source.html#l00603">603</a> of file <a class="el" href="surface__skd__tree_8cpp_source.html">surface_skd_tree.cpp</a>.</p>

</div>
</div>
<a id="a4bc9734da37cfb051f2034f73d51535c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bc9734da37cfb051f2034f73d51535c">&#9670;&nbsp;</a></span>findPointClosestGlobalCell() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long bitpit::SurfaceSkdTree::findPointClosestGlobalCell </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; *&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>maxDistance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long *&#160;</td>
          <td class="paramname"><em>ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ranks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>distances</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given the specified points, considered distributed on the processes, find the closest cells contained in the tree and evaluates the distance values between those cells and the given points.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nPoints</td><td>is the number of the points </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">points</td><td>are the points coordinates </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxDistance</td><td>all cells whose distance is greater than this parameters will not be considered for the evaluation of the distance </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ids</td><td>on output it will contain the ids of the cells closest to the points. If all cells contained in the tree are farther from a point than the maximum distance, the related id will be set to the null id </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ranks</td><td>on output it will contain the rank indices of the processes owner of the cells closest to the points </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">distances</td><td>on output it will contain the distances between the points and closest cells. If all cells contained in the tree are farther than the maximum distance, the related argument will be set to the maximum representable distance. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="surface__skd__tree_8cpp_source.html#l00575">575</a> of file <a class="el" href="surface__skd__tree_8cpp_source.html">surface_skd_tree.cpp</a>.</p>

</div>
</div>
<a id="a456a89a62a4e3f18fb8eff4b880a3a3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a456a89a62a4e3f18fb8eff4b880a3a3d">&#9670;&nbsp;</a></span>findPointClosestGlobalCell() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long bitpit::SurfaceSkdTree::findPointClosestGlobalCell </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; double, 3 &gt; *&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long *&#160;</td>
          <td class="paramname"><em>ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ranks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>distances</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given the specified points, considered distributed on the processes, find the closest cells contained in the tree and evaluates the distance values between those cells and the given points.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nPoints</td><td>is the number of the points </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">points</td><td>are the points coordinates </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ids</td><td>on output it will contain the ids of the cells closest to the local points </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ranks</td><td>on output it will contain the rank indices of the processes owner of the cells closest to the points </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">distances</td><td>on output it will contain the distances between the points and closest cells </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="surface__skd__tree_8cpp_source.html#l00550">550</a> of file <a class="el" href="surface__skd__tree_8cpp_source.html">surface_skd_tree.cpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/patchkernel/<a class="el" href="surface__skd__tree_8hpp_source.html">surface_skd_tree.hpp</a></li>
<li>src/patchkernel/<a class="el" href="surface__skd__tree_8cpp_source.html">surface_skd_tree.cpp</a></li>
</ul>
</div><!-- contents -->
---
layout: doxygen_footer
---
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<address class="footer"><small>
Generated on Mon Mar 29 2021 21:17:49 for bitpit by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.9.1
</small></address>
