---
layout: doxygen_header
title: Manual - Mathematical Operators
section: documentation
doxygen-show-titlearea: 0
extra-head-includes:
    - doxygen_extra_head.html
---
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
{% if page.doxygen-show-titlearea == 1 %}
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">bitpit
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
{% endif %}
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Mathematical Operators<div class="ingroups"><a class="el" href="group__OperatorsFunctions.html">Operators and Functions</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for Mathematical Operators:</div>
<div class="dyncontent">
<div class="center"><img src="group__MathOperators.png" border="0" usemap="#agroup____MathOperators" alt=""/></div>
<map name="agroup____MathOperators" id="agroup____MathOperators">
<area shape="rect" title=" " alt="" coords="219,5,380,31"/>
<area shape="rect" href="group__OperatorsFunctions.html" title=" " alt="" coords="5,5,171,31"/>
</map>
</div>
<table class="memberdecls">
<tr class="memitem:ga3f635ef98b56435afb45a039abf9e039"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d&gt; </td></tr>
<tr class="memitem:ga3f635ef98b56435afb45a039abf9e039"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, d &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga3f635ef98b56435afb45a039abf9e039">operator+</a> (const std::array&lt; T, d &gt; &amp;x, const std::array&lt; T, d &gt; &amp;y)</td></tr>
<tr class="separator:ga3f635ef98b56435afb45a039abf9e039"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7017c5d06814ac672157b881cc29f086"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d&gt; </td></tr>
<tr class="memitem:ga7017c5d06814ac672157b881cc29f086"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, d &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga7017c5d06814ac672157b881cc29f086">operator+</a> (const std::array&lt; T, d &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:ga7017c5d06814ac672157b881cc29f086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44d22adb8eb80a55b5379bbc4bcb9422"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d&gt; </td></tr>
<tr class="memitem:ga44d22adb8eb80a55b5379bbc4bcb9422"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, d &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga44d22adb8eb80a55b5379bbc4bcb9422">operator+</a> (const T &amp;x, const std::array&lt; T, d &gt; &amp;y)</td></tr>
<tr class="separator:ga44d22adb8eb80a55b5379bbc4bcb9422"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ba4d31507040c35f062537329b2f99d"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d, size_t e&gt; </td></tr>
<tr class="memitem:ga3ba4d31507040c35f062537329b2f99d"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; std::array&lt; T, e &gt;, d &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga3ba4d31507040c35f062537329b2f99d">operator+</a> (const T &amp;x, const std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;y)</td></tr>
<tr class="separator:ga3ba4d31507040c35f062537329b2f99d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46ab5d3f2416d30ad6ed556e513ca15e"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d, size_t e&gt; </td></tr>
<tr class="memitem:ga46ab5d3f2416d30ad6ed556e513ca15e"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; std::array&lt; T, e &gt;, d &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga46ab5d3f2416d30ad6ed556e513ca15e">operator+</a> (const std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:ga46ab5d3f2416d30ad6ed556e513ca15e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71c4e0f1fa74771e27be330e94c98fa1"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d&gt; </td></tr>
<tr class="memitem:ga71c4e0f1fa74771e27be330e94c98fa1"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, d &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga71c4e0f1fa74771e27be330e94c98fa1">operator+=</a> (std::array&lt; T, d &gt; &amp;x, const std::array&lt; T, d &gt; &amp;y)</td></tr>
<tr class="separator:ga71c4e0f1fa74771e27be330e94c98fa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0753f57c13e8860d7d89a3c1d38c2f73"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d&gt; </td></tr>
<tr class="memitem:ga0753f57c13e8860d7d89a3c1d38c2f73"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, d &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga0753f57c13e8860d7d89a3c1d38c2f73">operator+=</a> (std::array&lt; T, d &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:ga0753f57c13e8860d7d89a3c1d38c2f73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d4f03731e627c861ab285e02d00f7ff"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d, size_t e&gt; </td></tr>
<tr class="memitem:ga6d4f03731e627c861ab285e02d00f7ff"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga6d4f03731e627c861ab285e02d00f7ff">operator+=</a> (std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:ga6d4f03731e627c861ab285e02d00f7ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1da48a189e6261dbea01a0042d36a814"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d&gt; </td></tr>
<tr class="memitem:ga1da48a189e6261dbea01a0042d36a814"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, d &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga1da48a189e6261dbea01a0042d36a814">operator-</a> (const std::array&lt; T, d &gt; &amp;x, const std::array&lt; T, d &gt; &amp;y)</td></tr>
<tr class="separator:ga1da48a189e6261dbea01a0042d36a814"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3af61c1b7033247df0338ccce0e612d6"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d&gt; </td></tr>
<tr class="memitem:ga3af61c1b7033247df0338ccce0e612d6"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, d &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga3af61c1b7033247df0338ccce0e612d6">operator-</a> (const std::array&lt; T, d &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:ga3af61c1b7033247df0338ccce0e612d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga579c90a19cace79621439edbc2d4a73b"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d&gt; </td></tr>
<tr class="memitem:ga579c90a19cace79621439edbc2d4a73b"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, d &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga579c90a19cace79621439edbc2d4a73b">operator-</a> (const T &amp;x, const std::array&lt; T, d &gt; &amp;y)</td></tr>
<tr class="separator:ga579c90a19cace79621439edbc2d4a73b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga458d5cb02f35f9a5d5bb4ec188ff7df9"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d, size_t e&gt; </td></tr>
<tr class="memitem:ga458d5cb02f35f9a5d5bb4ec188ff7df9"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; std::array&lt; T, e &gt;, d &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga458d5cb02f35f9a5d5bb4ec188ff7df9">operator-</a> (const T &amp;x, const std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;y)</td></tr>
<tr class="separator:ga458d5cb02f35f9a5d5bb4ec188ff7df9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8afe15fc58c619bd07278b1b2bc1fba9"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d, size_t e&gt; </td></tr>
<tr class="memitem:ga8afe15fc58c619bd07278b1b2bc1fba9"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; std::array&lt; T, e &gt;, d &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga8afe15fc58c619bd07278b1b2bc1fba9">operator-</a> (const std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:ga8afe15fc58c619bd07278b1b2bc1fba9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae07c4511ff8846e22d929bdefc82cd46"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d&gt; </td></tr>
<tr class="memitem:gae07c4511ff8846e22d929bdefc82cd46"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, d &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#gae07c4511ff8846e22d929bdefc82cd46">operator-=</a> (std::array&lt; T, d &gt; &amp;x, const std::array&lt; T, d &gt; &amp;y)</td></tr>
<tr class="separator:gae07c4511ff8846e22d929bdefc82cd46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98e0e282c16ff506763346bbabbb27a2"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d&gt; </td></tr>
<tr class="memitem:ga98e0e282c16ff506763346bbabbb27a2"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, d &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga98e0e282c16ff506763346bbabbb27a2">operator-=</a> (std::array&lt; T, d &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:ga98e0e282c16ff506763346bbabbb27a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea724ee1533cefef0eeb081a124145f2"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d, size_t e&gt; </td></tr>
<tr class="memitem:gaea724ee1533cefef0eeb081a124145f2"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#gaea724ee1533cefef0eeb081a124145f2">operator-=</a> (std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:gaea724ee1533cefef0eeb081a124145f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d7733125c27824e1aa57ebae04b06a8"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d&gt; </td></tr>
<tr class="memitem:ga1d7733125c27824e1aa57ebae04b06a8"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, d &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga1d7733125c27824e1aa57ebae04b06a8">operator*</a> (const std::array&lt; T, d &gt; &amp;x, const std::array&lt; T, d &gt; &amp;y)</td></tr>
<tr class="separator:ga1d7733125c27824e1aa57ebae04b06a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4462ec066ada6e0be6054a50670510b9"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d&gt; </td></tr>
<tr class="memitem:ga4462ec066ada6e0be6054a50670510b9"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, d &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga4462ec066ada6e0be6054a50670510b9">operator*</a> (const std::array&lt; T, d &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:ga4462ec066ada6e0be6054a50670510b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c63fae35933caafc7d747052b96b2f2"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d&gt; </td></tr>
<tr class="memitem:ga6c63fae35933caafc7d747052b96b2f2"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, d &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga6c63fae35933caafc7d747052b96b2f2">operator*</a> (const T &amp;x, const std::array&lt; T, d &gt; &amp;y)</td></tr>
<tr class="separator:ga6c63fae35933caafc7d747052b96b2f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04c59fa6da7fc1146dac00e02084d5d6"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d, size_t e&gt; </td></tr>
<tr class="memitem:ga04c59fa6da7fc1146dac00e02084d5d6"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; std::array&lt; T, e &gt;, d &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga04c59fa6da7fc1146dac00e02084d5d6">operator*</a> (const T &amp;x, const std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;y)</td></tr>
<tr class="separator:ga04c59fa6da7fc1146dac00e02084d5d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga873023bbde7c283db20e88467cabf3d3"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d, size_t e&gt; </td></tr>
<tr class="memitem:ga873023bbde7c283db20e88467cabf3d3"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; std::array&lt; T, e &gt;, d &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga873023bbde7c283db20e88467cabf3d3">operator*</a> (const std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:ga873023bbde7c283db20e88467cabf3d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace0292340505d2a22841ce7b8960345b"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d&gt; </td></tr>
<tr class="memitem:gace0292340505d2a22841ce7b8960345b"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, d &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#gace0292340505d2a22841ce7b8960345b">operator*=</a> (std::array&lt; T, d &gt; &amp;x, const std::array&lt; T, d &gt; &amp;y)</td></tr>
<tr class="separator:gace0292340505d2a22841ce7b8960345b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3a09d793370ba100f19a3af3ec567a4"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d&gt; </td></tr>
<tr class="memitem:gaa3a09d793370ba100f19a3af3ec567a4"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, d &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#gaa3a09d793370ba100f19a3af3ec567a4">operator*=</a> (std::array&lt; T, d &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:gaa3a09d793370ba100f19a3af3ec567a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4182cfb7e85ce1cf28603be3ea64891"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d, size_t e&gt; </td></tr>
<tr class="memitem:gae4182cfb7e85ce1cf28603be3ea64891"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#gae4182cfb7e85ce1cf28603be3ea64891">operator*=</a> (std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:gae4182cfb7e85ce1cf28603be3ea64891"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf48b3511fe629a19ad6d343b3722b18f"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d&gt; </td></tr>
<tr class="memitem:gaf48b3511fe629a19ad6d343b3722b18f"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, d &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#gaf48b3511fe629a19ad6d343b3722b18f">operator/</a> (const std::array&lt; T, d &gt; &amp;x, const std::array&lt; T, d &gt; &amp;y)</td></tr>
<tr class="separator:gaf48b3511fe629a19ad6d343b3722b18f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d819f94a4f2c54f683086dfd60914fe"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d&gt; </td></tr>
<tr class="memitem:ga5d819f94a4f2c54f683086dfd60914fe"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, d &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga5d819f94a4f2c54f683086dfd60914fe">operator/</a> (const std::array&lt; T, d &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:ga5d819f94a4f2c54f683086dfd60914fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17f1060376be7df1fdfaf5372216bb03"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d&gt; </td></tr>
<tr class="memitem:ga17f1060376be7df1fdfaf5372216bb03"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, d &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga17f1060376be7df1fdfaf5372216bb03">operator/</a> (const T &amp;x, const std::array&lt; T, d &gt; &amp;y)</td></tr>
<tr class="separator:ga17f1060376be7df1fdfaf5372216bb03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5db31c5d90112637e4d2fa84eee9d7e"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d, size_t e&gt; </td></tr>
<tr class="memitem:gaa5db31c5d90112637e4d2fa84eee9d7e"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; std::array&lt; T, e &gt;, d &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#gaa5db31c5d90112637e4d2fa84eee9d7e">operator/</a> (const T &amp;x, const std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;y)</td></tr>
<tr class="separator:gaa5db31c5d90112637e4d2fa84eee9d7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb62dde4f70707cef0988601e7ae3c08"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d, size_t e&gt; </td></tr>
<tr class="memitem:gabb62dde4f70707cef0988601e7ae3c08"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; std::array&lt; T, e &gt;, d &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#gabb62dde4f70707cef0988601e7ae3c08">operator/</a> (const std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:gabb62dde4f70707cef0988601e7ae3c08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86745bdc619c80a87b7495a2be35b5be"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d&gt; </td></tr>
<tr class="memitem:ga86745bdc619c80a87b7495a2be35b5be"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, d &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga86745bdc619c80a87b7495a2be35b5be">operator/=</a> (std::array&lt; T, d &gt; &amp;x, const std::array&lt; T, d &gt; &amp;y)</td></tr>
<tr class="separator:ga86745bdc619c80a87b7495a2be35b5be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b7c612383329df772db1f49839fea19"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d&gt; </td></tr>
<tr class="memitem:ga5b7c612383329df772db1f49839fea19"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, d &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga5b7c612383329df772db1f49839fea19">operator/=</a> (std::array&lt; T, d &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:ga5b7c612383329df772db1f49839fea19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50403f99e949516bedf459d21540353c"><td class="memTemplParams" colspan="2">template&lt;class T , size_t d, size_t e&gt; </td></tr>
<tr class="memitem:ga50403f99e949516bedf459d21540353c"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga50403f99e949516bedf459d21540353c">operator/=</a> (std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:ga50403f99e949516bedf459d21540353c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71b722bb9670854ddfcb0e867620083f"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga71b722bb9670854ddfcb0e867620083f"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga71b722bb9670854ddfcb0e867620083f">operator+</a> (const std::vector&lt; T &gt; &amp;x, const std::vector&lt; T &gt; &amp;y)</td></tr>
<tr class="separator:ga71b722bb9670854ddfcb0e867620083f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97948a906b46303c7c654c84149dd9ee"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga97948a906b46303c7c654c84149dd9ee"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga97948a906b46303c7c654c84149dd9ee">operator+</a> (const std::vector&lt; T &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:ga97948a906b46303c7c654c84149dd9ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade9e3b35c5ed9d228bd242eaee48df2f"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gade9e3b35c5ed9d228bd242eaee48df2f"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#gade9e3b35c5ed9d228bd242eaee48df2f">operator+</a> (const T &amp;x, const std::vector&lt; T &gt; &amp;y)</td></tr>
<tr class="separator:gade9e3b35c5ed9d228bd242eaee48df2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06cb1fde86b09befdc0b42d99fdbf31f"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga06cb1fde86b09befdc0b42d99fdbf31f"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga06cb1fde86b09befdc0b42d99fdbf31f">operator+</a> (const std::vector&lt; std::vector&lt; T &gt; &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:ga06cb1fde86b09befdc0b42d99fdbf31f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e163effd6e58c7f726fbd29f5c1e42c"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga6e163effd6e58c7f726fbd29f5c1e42c"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga6e163effd6e58c7f726fbd29f5c1e42c">operator+</a> (const T &amp;x, const std::vector&lt; std::vector&lt; T &gt; &gt; &amp;y)</td></tr>
<tr class="separator:ga6e163effd6e58c7f726fbd29f5c1e42c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a54e162a0893a716a8e767bccc5bcf6"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga4a54e162a0893a716a8e767bccc5bcf6"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga4a54e162a0893a716a8e767bccc5bcf6">operator+=</a> (std::vector&lt; T &gt; &amp;x, const std::vector&lt; T &gt; &amp;y)</td></tr>
<tr class="separator:ga4a54e162a0893a716a8e767bccc5bcf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga043993b9b79a9ae8c6311907bf739c83"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga043993b9b79a9ae8c6311907bf739c83"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga043993b9b79a9ae8c6311907bf739c83">operator+=</a> (std::vector&lt; T &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:ga043993b9b79a9ae8c6311907bf739c83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7b6c9177a03b67eb4d3746d11295984"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gaf7b6c9177a03b67eb4d3746d11295984"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; T &gt; &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#gaf7b6c9177a03b67eb4d3746d11295984">operator+=</a> (std::vector&lt; std::vector&lt; T &gt; &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:gaf7b6c9177a03b67eb4d3746d11295984"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39b3f7b4938cab605085cc4a2621c0c1"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga39b3f7b4938cab605085cc4a2621c0c1"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga39b3f7b4938cab605085cc4a2621c0c1">operator-</a> (const std::vector&lt; T &gt; &amp;x, const std::vector&lt; T &gt; &amp;y)</td></tr>
<tr class="separator:ga39b3f7b4938cab605085cc4a2621c0c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b14f28bd4c6544e7af363162827a3f9"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga8b14f28bd4c6544e7af363162827a3f9"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga8b14f28bd4c6544e7af363162827a3f9">operator-</a> (const std::vector&lt; T &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:ga8b14f28bd4c6544e7af363162827a3f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81916c6a47f24b1ec5bfb890a7e71d93"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga81916c6a47f24b1ec5bfb890a7e71d93"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga81916c6a47f24b1ec5bfb890a7e71d93">operator-</a> (const T &amp;x, const std::vector&lt; T &gt; &amp;y)</td></tr>
<tr class="separator:ga81916c6a47f24b1ec5bfb890a7e71d93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd869d6ee14d5683b3fa4fcefc5ae5fa"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gacd869d6ee14d5683b3fa4fcefc5ae5fa"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#gacd869d6ee14d5683b3fa4fcefc5ae5fa">operator-</a> (const T &amp;x, const std::vector&lt; std::vector&lt; T &gt; &gt; &amp;y)</td></tr>
<tr class="separator:gacd869d6ee14d5683b3fa4fcefc5ae5fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga043799b065672b453653cccc836df3e0"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga043799b065672b453653cccc836df3e0"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga043799b065672b453653cccc836df3e0">operator-</a> (const std::vector&lt; std::vector&lt; T &gt; &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:ga043799b065672b453653cccc836df3e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0aacb9fe943aadde419e168ee051f35f"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga0aacb9fe943aadde419e168ee051f35f"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga0aacb9fe943aadde419e168ee051f35f">operator-=</a> (std::vector&lt; T &gt; &amp;x, const std::vector&lt; T &gt; &amp;y)</td></tr>
<tr class="separator:ga0aacb9fe943aadde419e168ee051f35f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2595b252e76781008f28f0d4259abd6"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gac2595b252e76781008f28f0d4259abd6"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#gac2595b252e76781008f28f0d4259abd6">operator-=</a> (std::vector&lt; T &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:gac2595b252e76781008f28f0d4259abd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8734f21e1ba10ab0e30ca2d98ac458c7"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga8734f21e1ba10ab0e30ca2d98ac458c7"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; T &gt; &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga8734f21e1ba10ab0e30ca2d98ac458c7">operator-=</a> (std::vector&lt; std::vector&lt; T &gt; &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:ga8734f21e1ba10ab0e30ca2d98ac458c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2bd9e5a66f35bd5cfe4903f2405c87ba"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga2bd9e5a66f35bd5cfe4903f2405c87ba"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga2bd9e5a66f35bd5cfe4903f2405c87ba">operator*</a> (const std::vector&lt; T &gt; &amp;x, const std::vector&lt; T &gt; &amp;y)</td></tr>
<tr class="separator:ga2bd9e5a66f35bd5cfe4903f2405c87ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac44d2a365e67d48fc144cf576f4e003e"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gac44d2a365e67d48fc144cf576f4e003e"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#gac44d2a365e67d48fc144cf576f4e003e">operator*</a> (const std::vector&lt; T &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:gac44d2a365e67d48fc144cf576f4e003e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92fa8968855d071e34808339503fe37b"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga92fa8968855d071e34808339503fe37b"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga92fa8968855d071e34808339503fe37b">operator*</a> (const T &amp;x, const std::vector&lt; T &gt; &amp;y)</td></tr>
<tr class="separator:ga92fa8968855d071e34808339503fe37b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5c14d292d187b6a76d4acd8068e2ec3"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gae5c14d292d187b6a76d4acd8068e2ec3"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#gae5c14d292d187b6a76d4acd8068e2ec3">operator*</a> (const T &amp;x, const std::vector&lt; std::vector&lt; T &gt; &gt; &amp;y)</td></tr>
<tr class="separator:gae5c14d292d187b6a76d4acd8068e2ec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5be9b506ad98c26a66c46e3a63569af2"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga5be9b506ad98c26a66c46e3a63569af2"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga5be9b506ad98c26a66c46e3a63569af2">operator*</a> (const std::vector&lt; std::vector&lt; T &gt; &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:ga5be9b506ad98c26a66c46e3a63569af2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53e59ed744d940c52f17237762edeb63"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga53e59ed744d940c52f17237762edeb63"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga53e59ed744d940c52f17237762edeb63">operator*=</a> (std::vector&lt; T &gt; &amp;x, const std::vector&lt; T &gt; &amp;y)</td></tr>
<tr class="separator:ga53e59ed744d940c52f17237762edeb63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7bb44d4987361a698f36b0b43da90ec7"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga7bb44d4987361a698f36b0b43da90ec7"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga7bb44d4987361a698f36b0b43da90ec7">operator*=</a> (std::vector&lt; T &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:ga7bb44d4987361a698f36b0b43da90ec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56a1b2553cf1c204e208ddf55fdfbff0"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga56a1b2553cf1c204e208ddf55fdfbff0"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; T &gt; &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga56a1b2553cf1c204e208ddf55fdfbff0">operator*=</a> (std::vector&lt; std::vector&lt; T &gt; &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:ga56a1b2553cf1c204e208ddf55fdfbff0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d9d274530965b0fb1a331706535b2b0"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga4d9d274530965b0fb1a331706535b2b0"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga4d9d274530965b0fb1a331706535b2b0">operator/</a> (const std::vector&lt; T &gt; &amp;x, const std::vector&lt; T &gt; &amp;y)</td></tr>
<tr class="separator:ga4d9d274530965b0fb1a331706535b2b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ee9c85d60d975df735a1c35fcf02e20"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga9ee9c85d60d975df735a1c35fcf02e20"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga9ee9c85d60d975df735a1c35fcf02e20">operator/</a> (const std::vector&lt; T &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:ga9ee9c85d60d975df735a1c35fcf02e20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6fff4de3b1f6cbedc8b80e0f29b673f"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gac6fff4de3b1f6cbedc8b80e0f29b673f"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#gac6fff4de3b1f6cbedc8b80e0f29b673f">operator/</a> (const T &amp;x, const std::vector&lt; T &gt; &amp;y)</td></tr>
<tr class="separator:gac6fff4de3b1f6cbedc8b80e0f29b673f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa8866a1e9873585704acfa8169ba1f4"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gaaa8866a1e9873585704acfa8169ba1f4"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#gaaa8866a1e9873585704acfa8169ba1f4">operator/</a> (const T &amp;x, const std::vector&lt; std::vector&lt; T &gt; &gt; &amp;y)</td></tr>
<tr class="separator:gaaa8866a1e9873585704acfa8169ba1f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab73845b94584f17c7e810e27cba36f5d"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gab73845b94584f17c7e810e27cba36f5d"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#gab73845b94584f17c7e810e27cba36f5d">operator/</a> (const std::vector&lt; std::vector&lt; T &gt; &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:gab73845b94584f17c7e810e27cba36f5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabef2e8a23bc01ea9a02f8478705a8055"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gabef2e8a23bc01ea9a02f8478705a8055"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#gabef2e8a23bc01ea9a02f8478705a8055">operator/=</a> (std::vector&lt; T &gt; &amp;x, const std::vector&lt; T &gt; &amp;y)</td></tr>
<tr class="separator:gabef2e8a23bc01ea9a02f8478705a8055"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1c760c866b18096f41015d84c1ba517"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gad1c760c866b18096f41015d84c1ba517"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#gad1c760c866b18096f41015d84c1ba517">operator/=</a> (std::vector&lt; T &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:gad1c760c866b18096f41015d84c1ba517"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga661186ca419d7b771ea549dc2bee4229"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga661186ca419d7b771ea549dc2bee4229"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; T &gt; &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MathOperators.html#ga661186ca419d7b771ea549dc2bee4229">operator/=</a> (std::vector&lt; std::vector&lt; T &gt; &gt; &amp;x, const T &amp;y)</td></tr>
<tr class="separator:ga661186ca419d7b771ea549dc2bee4229"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga873023bbde7c283db20e88467cabf3d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga873023bbde7c283db20e88467cabf3d3">&#9670;&nbsp;</a></span>operator*() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d, size_t e&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;std::array&lt;T, e&gt;, d&gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator* for std::array.</p>
<p>Perform the element-wise product between a array of arrays (x) and a constant (y), and returns z s.t. z[i][j] = x[i][j] * y for all j = 0, ..., e-1, i = 0, ..., d-1 where d = x.size(). Template parameters, T, can by any type for which the operator* is defined.</p>
<p>The element-wise product is performed recursively, i.e. if x[i][j] and y are std::array, operator* calls itself to perform the element-wise product between x[i][j] and y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array of arrays having the same dimensions of x and storing the element-wise product between x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l00871">871</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="ga1d7733125c27824e1aa57ebae04b06a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1d7733125c27824e1aa57ebae04b06a8">&#9670;&nbsp;</a></span>operator*() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;T, d&gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; T, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; T, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator* for std::array.</p>
<p>Perform the element-wise product between two arrays (x and y) and returns a array z s.t. z[i] = x[i] * y[i] for all i = 0, ..., d-1 where d = min(x.size(), y.size(). Template parameters, T, can by any type for which the operator* is defined.</p>
<p>The element-wise product is performed recursively, i.e. if the i-th element of x and the i-th element of y are std::array, operator* calls itself to perform the element-wise product between x[i] and y[i].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array with d elements, storing the element-wise product between x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l00715">715</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="ga4462ec066ada6e0be6054a50670510b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4462ec066ada6e0be6054a50670510b9">&#9670;&nbsp;</a></span>operator*() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;T, d&gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; T, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator* for std::array.</p>
<p>Perform the element-wise product between a array (x) and a constant (y), and returns a array (z) s.t. z[i] = x[i] * y for all i = 0, ..., d-1 where d = x.size(). Template parameters, T, can by any type for which the operator* is defined.</p>
<p>The element-wise product is performed recursively, i.e. if the i-th element of x and y are std::array, operator* calls itself to perform the element-wise product between x[i] and y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array with d elements, storing the element-wise product between x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l00754">754</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="ga5be9b506ad98c26a66c46e3a63569af2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5be9b506ad98c26a66c46e3a63569af2">&#9670;&nbsp;</a></span>operator*() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; T &gt; &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator* for std::vector.</p>
<p>Perform the element-wise product between a vector of vectors (x) and a constant (y), and returns z s.t. z[i][j] = x[i][j] * y for all j = 0, ..., x[i].size()-1, i = 0, ..., n-1 where n = x.size(). Template parameters, T, can by any type for which the operator* is defined.</p>
<p>The element-wise product is performed recursively, i.e. if x[i][j] and y are std::vector, operator* calls itself to perform the element-wise product between x[i][j] and y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of vectors having the same dimensions of x and storing the element-wise product between x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l00862">862</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="ga2bd9e5a66f35bd5cfe4903f2405c87ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2bd9e5a66f35bd5cfe4903f2405c87ba">&#9670;&nbsp;</a></span>operator*() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator* for std::vector.</p>
<p>Perform the element-wise product between two vectors (x and y) and returns a vector z s.t. z[i] = x[i] * y[i] for all i = 0, ..., n-1 where n = min(x.size(), y.size(). Template parameters, T, can by any type for which the operator* is defined.</p>
<p>The element-wise product is performed recursively, i.e. if the i-th element of x and the i-th element of y are std::vector, operator* calls itself to perform the element-wise product between x[i] and y[i].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector with n elements, storing the element-wise product between x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l00703">703</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="gac44d2a365e67d48fc144cf576f4e003e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac44d2a365e67d48fc144cf576f4e003e">&#9670;&nbsp;</a></span>operator*() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator* for std::vector.</p>
<p>Perform the element-wise product between a vector (x) and a constant (y), and returns a vector (z) s.t. z[i] = x[i] * y for all i = 0, ..., n-1 where n = x.size(). Template parameters, T, can by any type for which the operator* is defined.</p>
<p>The element-wise product is performed recursively, i.e. if the i-th element of x and y are std::vector, operator* calls itself to perform the element-wise product between x[i] and y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector with n elements, storing the element-wise product between x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l00743">743</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="ga04c59fa6da7fc1146dac00e02084d5d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga04c59fa6da7fc1146dac00e02084d5d6">&#9670;&nbsp;</a></span>operator*() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d, size_t e&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;std::array&lt;T, e&gt;, d&gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator* for std::array.</p>
<p>Perform the element-wise product between a constant (y) and a array of arrays (y), and returns z s.t. z[i][j] = x * y[i][j] for all j = 0, ..., e-1, i = 0, ..., d-1 where d = y.size(). Template parameters, T, can by any type for which the operator* is defined.</p>
<p>The element-wise product is performed recursively, i.e. if y[i][j] and y are std::array, operator* calls itself to perform the element-wise product between y[i][j] and x.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array of arrays having the same dimensions of y and storing the element-wise product between x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l00831">831</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="ga6c63fae35933caafc7d747052b96b2f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6c63fae35933caafc7d747052b96b2f2">&#9670;&nbsp;</a></span>operator*() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;T, d&gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; T, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator* for std::array.</p>
<p>Perform the element-wise product between a constant (x), and a array (y) and returns a array (z) s.t. z[i] = x * y[i] for all i = 0, ..., d-1 where d = y.size(). Template parameters, T, can by any type for which the operator* is defined.</p>
<p>The element-wise product is performed recursively, i.e. if the i-th element of y and x are std::array, operator* calls itself to perform the element-wise product between x[i] and y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array with d elements, storing the element-wise product between x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l00793">793</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="gae5c14d292d187b6a76d4acd8068e2ec3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae5c14d292d187b6a76d4acd8068e2ec3">&#9670;&nbsp;</a></span>operator*() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; T &gt; &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator* for std::vector.</p>
<p>Perform the element-wise product between a constant (y) and a vector of vectors (y), and returns z s.t. z[i][j] = x * y[i][j] for all j = 0, ..., y[i].size()-1, i = 0, ..., n-1 where n = y.size(). Template parameters, T, can by any type for which the operator* is defined.</p>
<p>The element-wise product is performed recursively, i.e. if y[i][j] and y are std::vector, operator* calls itself to perform the element-wise product between y[i][j] and x.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of vectors having the same dimensions of y and storing the element-wise product between x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l00821">821</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="ga92fa8968855d071e34808339503fe37b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga92fa8968855d071e34808339503fe37b">&#9670;&nbsp;</a></span>operator*() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator* for std::vector.</p>
<p>Perform the element-wise product between a constant (x), and a vector (y) and returns a vector (z) s.t. z[i] = x * y[i] for all i = 0, ..., n-1 where n = y.size(). Template parameters, T, can by any type for which the operator* is defined.</p>
<p>The element-wise product is performed recursively, i.e. if the i-th element of y and x are std::vector, operator* calls itself to perform the element-wise product between x[i] and y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector with n elements, storing the element-wise product between x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l00783">783</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="gae4182cfb7e85ce1cf28603be3ea64891"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae4182cfb7e85ce1cf28603be3ea64891">&#9670;&nbsp;</a></span>operator*=() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d, size_t e&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; std::array&lt; T, e &gt;, d &gt;&amp; operator*= </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator*= for std::array.</p>
<p>Increment each element in the input array, using the value on the r.h.s. as increment, i.e.: x[i][j] *= y for all j = 0, ..., e-1, i = 0, ..., d-1 Template parameters, T, can by any type for which the operator*= is defined.</p>
<p>The element-wise increment is performed recursively, i.e. if x[i][j] and y are std::array, operator*= calls itself to increment x[i][j][k] by y[k], k = 0, ... , x.size()-1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first argument incremented with r.h.s. values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l00987">987</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="gace0292340505d2a22841ce7b8960345b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gace0292340505d2a22841ce7b8960345b">&#9670;&nbsp;</a></span>operator*=() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; T, d &gt;&amp; operator*= </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; T, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; T, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator*= for std::array.</p>
<p>Increment each element in the input array, using the corresping value on array at the r.h.s. as increment, i.e.: x[i] *= y[i] for all i = 0, ..., d-1 Template parameters, T, can by any type for which the operator+= is defined.</p>
<p>The element-wise increment is performed recursively, i.e. if the i-th element of x and the i-th element of y are std::array, operator*= calls itself to increment x[i][j] by y[i][j], j = 0, ..., x[i].size()-1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first argument incremented with r.h.s. values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l00911">911</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="gaa3a09d793370ba100f19a3af3ec567a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa3a09d793370ba100f19a3af3ec567a4">&#9670;&nbsp;</a></span>operator*=() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; T, d &gt;&amp; operator*= </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; T, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator*= for std::array.</p>
<p>Increment each element in the input array, using the value on the r.h.s. as increment, i.e.: x[i] *= y for all i = 0, ..., d-1 Template parameters, T, can by any type for which the operator*= is defined.</p>
<p>The element-wise increment is performed recursively, i.e. if the i-th element of x and y are std::array, operator*= calls itself to increment x[i][j] by y[j], j = 0, ... , x[i].size()-1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first argument incremented with r.h.s. values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l00949">949</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="ga56a1b2553cf1c204e208ddf55fdfbff0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga56a1b2553cf1c204e208ddf55fdfbff0">&#9670;&nbsp;</a></span>operator*=() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; T &gt; &gt;&amp; operator*= </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator*= for std::vector.</p>
<p>Increment each element in the input vector, using the value on the r.h.s. as increment, i.e.: x[i][j] *= y for all j = 0, ..., x[i].size()-1, i = 0, ..., n-1 where n = x.size(). Template parameters, T, can by any type for which the operator*= is defined.</p>
<p>The element-wise increment is performed recursively, i.e. if x[i][j] and y are std::vector, operator*= calls itself to increment x[i][j][k] by y[k], k = 0, ... , min(x[i][j].size(), y.size())-1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first argument incremented with r.h.s. values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l00979">979</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="ga53e59ed744d940c52f17237762edeb63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga53e59ed744d940c52f17237762edeb63">&#9670;&nbsp;</a></span>operator*=() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt;&amp; operator*= </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator*= for std::vector.</p>
<p>Increment each element in the input vector, using the corresping value on vector at the r.h.s. as increment, i.e.: x[i] *= y[i] for all i = 0, ..., n-1 where n = min(x.size(), y.size(). Template parameters, T, can by any type for which the operator*= is defined.</p>
<p>The element-wise increment is performed recursively, i.e. if the i-th element of x and the i-th element of y are std::vector, operator*= calls itself to increment x[i][j] by y[i][j], j = 0, ..., min(x[i].size(), y[i].size())-1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first argument incremented with r.h.s. values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l00901">901</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="ga7bb44d4987361a698f36b0b43da90ec7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7bb44d4987361a698f36b0b43da90ec7">&#9670;&nbsp;</a></span>operator*=() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt;&amp; operator*= </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator*= for std::vector.</p>
<p>Increment each element in the input vector, using the value on the r.h.s. as increment, i.e.: x[i] *= y for all i = 0, ..., n-1 where n = x.size(). Template parameters, T, can by any type for which the operator*= is defined.</p>
<p>The element-wise increment is performed recursively, i.e. if the i-th element of x and y are std::vector, operator*= calls itself to increment x[i][j] by y[j], j = 0, ... , min(x[i].size(), y.size())-1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first argument incremented with r.h.s. values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l00940">940</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="ga46ab5d3f2416d30ad6ed556e513ca15e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga46ab5d3f2416d30ad6ed556e513ca15e">&#9670;&nbsp;</a></span>operator+() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d, size_t e&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;std::array&lt;T, e&gt;, d&gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator+ for std::array.</p>
<p>Perform the element-wise sum between a constant (y) and a array of arrays (y), and returns z s.t. z[i][j] = x + y[i][j] for all j = 0, ..., e-1, i = 0, ..., d-1 where d = y.size(). Template parameters, T, can by any type for which the operator+ is defined.</p>
<p>The element-wise sum is performed recursively, i.e. if y[i][j] and y are std::array, operator+ calls itself to perform the element-wise sum between y[i][j] and x.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array of arrays having the same dimensions of y and storing the element-wise sum of x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l00230">230</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="ga3f635ef98b56435afb45a039abf9e039"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3f635ef98b56435afb45a039abf9e039">&#9670;&nbsp;</a></span>operator+() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;T, d&gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; T, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; T, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator+ for std::array</p>
<p>Perform the element-wise sum between two arrays (x and y) and returns a array z s.t. z[i] = x[i] + y[i] for all i = 0, ..., d where d = x.size() = y.size(). Template parameters, T, can by any type for which the operator+ is defined.</p>
<p>The element-wise sum is performed recursively, i.e. if the i-th element of x and the i-th element of y are std::array, operator+ calls itself to perform the element-wise sum between x[i] and y[i].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array with d elements, storing the element-wise sum of x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l00074">74</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="ga7017c5d06814ac672157b881cc29f086"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7017c5d06814ac672157b881cc29f086">&#9670;&nbsp;</a></span>operator+() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;T, d&gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; T, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator+ for std::array.</p>
<p>Perform the element-wise sum between a array (x) and a constant (y), and returns a array (z) s.t. z[i] = x[i] + y for all i = 0, ..., d where d = x.size(). Template parameters, T, can by any type for which the operator+ is defined.</p>
<p>The element-wise sum is performed recursively, i.e. if the i-th element of x and y are std::array, operator+ calls itself to perform the element-wise sum between x[i] and y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array with d elements, storing the element-wise sum of x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l00113">113</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="ga06cb1fde86b09befdc0b42d99fdbf31f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga06cb1fde86b09befdc0b42d99fdbf31f">&#9670;&nbsp;</a></span>operator+() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; T &gt; &gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator+ for std::vector.</p>
<p>Perform the element-wise sum between a vector of vectors (x) and a constant (y), and returns z s.t. z[i][j] = x[i][j] + y for all j = 0, ..., x[i].size()-1, i = 0, ..., n-1 where n = x.size(). Template parameters, T, can by any type for which the operator+ is defined.</p>
<p>The element-wise sum is performed recursively, i.e. if x[i][j] and y are std::vector, operator+ calls itself to perform the element-wise sum between x[i][j] and y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of vectors having the same dimensions of x and storing the element-wise sum of x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l00187">187</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="ga71b722bb9670854ddfcb0e867620083f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga71b722bb9670854ddfcb0e867620083f">&#9670;&nbsp;</a></span>operator+() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator+ for std::vector.</p>
<p>Perform the element-wise sum between two vectors (x and y) and returns a vector z s.t. z[i] = x[i] + y[i] for all i = 0, ..., n-1 where n = std::min(x.size(), y.size(). Template parameters, T, can by any type for which the operator+ is defined.</p>
<p>The element-wise sum is performed recursively, i.e. if the i-th element of x and the i-th element of y are std::vector, operator+ calls itself to perform the element-wise sum between x[i] and y[i].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector with n elements, storing the element-wise sum of x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l00069">69</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="ga97948a906b46303c7c654c84149dd9ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga97948a906b46303c7c654c84149dd9ee">&#9670;&nbsp;</a></span>operator+() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator+ for std::vector.</p>
<p>Perform the element-wise sum between a vector (x) and a constant (y), and returns a vector (z) s.t. z[i] = x[i] + y for all i = 0, ..., n-1 where n = x.size(). Template parameters, T, can by any type for which the operator+ is defined.</p>
<p>The element-wise sum is performed recursively, i.e. if the i-th element of x and y are std::vector, operator+ calls itself to perform the element-wise sum between x[i] and y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector with n elements, storing the element-wise sum of x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l00109">109</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="ga3ba4d31507040c35f062537329b2f99d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3ba4d31507040c35f062537329b2f99d">&#9670;&nbsp;</a></span>operator+() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d, size_t e&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;std::array&lt;T, e&gt;, d&gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator+ for std::array.</p>
<p>Perform the element-wise sum between a array of arrays (x) and a constant (y), and returns z s.t. z[i][j] = x[i][j] + y for all j = 0, ..., e-1, i = 0, ..., d-1 where d = x.size(). Template parameters, T, can by any type for which the operator+ is defined.</p>
<p>The element-wise sum is performed recursively, i.e. if x[i][j] and y are std::array, operator+ calls itself to perform the element-wise sum between x[i][j] and y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array of arrays having the same dimensions of x and storing the element-wise sum of x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l00190">190</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="ga44d22adb8eb80a55b5379bbc4bcb9422"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga44d22adb8eb80a55b5379bbc4bcb9422">&#9670;&nbsp;</a></span>operator+() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;T, d&gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; T, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator+ for std::array.</p>
<p>Perform the element-wise sum between a constant (x), and a array (y) and returns a array (z) s.t. z[i] = x + y[i] for all i = 0, ..., d where d = y.size(). Template parameters, T, can by any type for which the operator+ is defined.</p>
<p>The element-wise sum is performed recursively, i.e. if the i-th element of y and x are std::array, operator+ calls itself to perform the element-wise sum between x[i] and y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array with d elements, storing the element-wise sum of x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l00152">152</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="ga6e163effd6e58c7f726fbd29f5c1e42c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6e163effd6e58c7f726fbd29f5c1e42c">&#9670;&nbsp;</a></span>operator+() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; T &gt; &gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator+ for std::vector.</p>
<p>Perform the element-wise sum between a constant (y) and a vector of vectors (y), and returns z s.t. z[i][j] = x + y[i][j] for all j = 0, ..., y[i].size()-1, i = 0, ..., n-1 where n = y.size(). Template parameters, T, can by any type for which the operator+ is defined.</p>
<p>The element-wise sum is performed recursively, i.e. if y[i][j] and y are std::vector, operator+ calls itself to perform the element-wise sum between y[i][j] and x.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of vectors having the same dimensions of y and storing the element-wise sum of x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l00228">228</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="gade9e3b35c5ed9d228bd242eaee48df2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gade9e3b35c5ed9d228bd242eaee48df2f">&#9670;&nbsp;</a></span>operator+() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator+ for std::vector.</p>
<p>Perform the element-wise sum between a constant (x), and a vector (y) and returns a vector (z) s.t. z[i] = x + y[i] for all i = 0, ..., n-1 where n = y.size(). Template parameters, T, can by any type for which the operator+ is defined.</p>
<p>The element-wise sum is performed recursively, i.e. if the i-th element of y and x are std::vector, operator+ calls itself to perform the element-wise sum between x[i] and y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector with n elements, storing the element-wise sum of x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l00149">149</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="ga6d4f03731e627c861ab285e02d00f7ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6d4f03731e627c861ab285e02d00f7ff">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d, size_t e&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; std::array&lt; T, e &gt;, d &gt;&amp; operator+= </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator+= for std::array.</p>
<p>Increment each element in the input array, using the value on the r.h.s. as increment, i.e.: x[i][j] += y for all j = 0, ..., e-1, i = 0, ..., d-1 Template parameters, T, can by any type for which the operator+= is defined.</p>
<p>The element-wise increment is performed recursively, i.e. if x[i][j] and y are std::array, operator+= calls itself to increment x[i][j][k] by y[k], k = 0, ... , x.size()-1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first argument incremented with r.h.s. values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l00344">344</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="ga71c4e0f1fa74771e27be330e94c98fa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga71c4e0f1fa74771e27be330e94c98fa1">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; T, d &gt;&amp; operator+= </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; T, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; T, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator+= for std::array.</p>
<p>Increment each element in the input array, using the corresping value on array at the r.h.s. as increment, i.e.: x[i] += y[i] for all i = 0, ..., d-1 Template parameters, T, can by any type for which the operator+= is defined.</p>
<p>The element-wise increment is performed recursively, i.e. if the i-th element of x and the i-th element of y are std::array, operator+= calls itself to increment x[i][j] by y[i][j], j = 0, ..., x[i].size()-1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first argument incremented with r.h.s. values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l00268">268</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="ga0753f57c13e8860d7d89a3c1d38c2f73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0753f57c13e8860d7d89a3c1d38c2f73">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; T, d &gt;&amp; operator+= </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; T, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator+= for std::array.</p>
<p>Increment each element in the input array, using the value on the r.h.s. as increment, i.e.: x[i] += y for all i = 0, ..., d-1 Template parameters, T, can by any type for which the operator+= is defined.</p>
<p>The element-wise increment is performed recursively, i.e. if the i-th element of x and y are std::array, operator+= calls itself to increment x[i][j] by y[j], j = 0, ... , x[i].size()-1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first argument incremented with r.h.s. values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l00306">306</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="gaf7b6c9177a03b67eb4d3746d11295984"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf7b6c9177a03b67eb4d3746d11295984">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; T &gt; &gt;&amp; operator+= </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator+= for std::vector.</p>
<p>Increment each element in the input vector, using the value on the r.h.s. as increment, i.e.: x[i][j] += y for all j = 0, ..., x[i].size()-1, i = 0, ..., n-1 where n = x.size(). Template parameters, T, can by any type for which the operator+= is defined.</p>
<p>The element-wise increment is performed recursively, i.e. if x[i][j] and y are std::vector, operator+= calls itself to increment x[i][j][k] by y[k], k = 0, ... , min(x[i][j].size(), y.size())-1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first argument incremented with r.h.s. values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l00345">345</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="ga4a54e162a0893a716a8e767bccc5bcf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4a54e162a0893a716a8e767bccc5bcf6">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt;&amp; operator+= </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator+= for std::vector.</p>
<p>Increment each element in the input vector, using the corresping value on vector at the r.h.s. as increment, i.e.: x[i] += y[i] for all i = 0, ..., n-1 where n = min(x.size(), y.size(). Template parameters, T, can by any type for which the operator+= is defined.</p>
<p>The element-wise increment is performed recursively, i.e. if the i-th element of x and the i-th element of y are std::vector, operator+= calls itself to increment x[i][j] by y[i][j], j = 0, ..., min(x[i].size(), y[i].size())-1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first argument incremented with r.h.s. values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l00267">267</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="ga043993b9b79a9ae8c6311907bf739c83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga043993b9b79a9ae8c6311907bf739c83">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt;&amp; operator+= </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator+= for std::vector.</p>
<p>Increment each element in the input vector, using the value on the r.h.s. as increment, i.e.: x[i] += y for all i = 0, ..., n-1 where n = x.size(). Template parameters, T, can by any type for which the operator+= is defined.</p>
<p>The element-wise increment is performed recursively, i.e. if the i-th element of x and y are std::vector, operator+= calls itself to increment x[i][j] by y[j], j = 0, ... , min(x[i].size(), y.size())-1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first argument incremented with r.h.s. values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l00306">306</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="ga8afe15fc58c619bd07278b1b2bc1fba9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8afe15fc58c619bd07278b1b2bc1fba9">&#9670;&nbsp;</a></span>operator-() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d, size_t e&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;std::array&lt;T, e&gt;, d&gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator- for std::array.</p>
<p>Perform the element-wise difference between a array of arrays (x) and a constant (y), and returns z s.t. z[i][j] = x[i][j] - y for all j = 0, ..., e-1, i = 0, ..., d-1 where n = x.size(). Template parameters, T, can by any type for which the operator- is defined.</p>
<p>The element-wise difference is performed recursively, i.e. if x[i][j] and y are std::array, operator. calls itself to perform the element-wise difference between x[i][j] and y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array of arrays having the same dimensions of x and storing the element-wise difference between x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l00541">541</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="ga1da48a189e6261dbea01a0042d36a814"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1da48a189e6261dbea01a0042d36a814">&#9670;&nbsp;</a></span>operator-() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;T, d&gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; T, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; T, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator- for std::array.</p>
<p>Perform the element-wise difference between two arrays (x and y) and returns a array z s.t. z[i] = x[i] - y[i] for all i = 0, ..., d-1 where d = min(x.size(), y.size(). Template parameters, T, can by any type for which the operator- is defined.</p>
<p>The element-wise difference is performed recursively, i.e. if the i-th element of x and the i-th element of y are std::array, operator- calls itself to perform the element-wise difference between x[i] and y[i].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array with n elements, storing the element-wise difference between x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l00385">385</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="ga3af61c1b7033247df0338ccce0e612d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3af61c1b7033247df0338ccce0e612d6">&#9670;&nbsp;</a></span>operator-() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;T, d&gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; T, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator- for std::array.</p>
<p>Perform the element-wise difference between a array (x) and a constant (y), and returns a array (z) s.t. z[i] = x[i] - y for all i = 0, ..., d-1 where d = x.size(). Template parameters, T, can by any type for which the operator- is defined.</p>
<p>The element-wise difference is performed recursively, i.e. if the i-th element of x and y are std::array, operator- calls itself to perform the element-wise difference between x[i] and y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array with d elements, storing the element-wise difference between x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l00424">424</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="ga043799b065672b453653cccc836df3e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga043799b065672b453653cccc836df3e0">&#9670;&nbsp;</a></span>operator-() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; T &gt; &gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator- for std::vector.</p>
<p>Perform the element-wise difference between a vector of vectors (x) and a constant (y), and returns z s.t. z[i][j] = x[i][j] - y for all j = 0, ..., x[i].size()-1, i = 0, ..., n-1 where n = x.size(). Template parameters, T, can by any type for which the operator- is defined.</p>
<p>The element-wise difference is performed recursively, i.e. if x[i][j] and y are std::vector, operator. calls itself to perform the element-wise difference between x[i][j] and y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of vectors having the same dimensions of x and storing the element-wise difference between x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l00545">545</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="ga39b3f7b4938cab605085cc4a2621c0c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga39b3f7b4938cab605085cc4a2621c0c1">&#9670;&nbsp;</a></span>operator-() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator- for std::vector.</p>
<p>Perform the element-wise difference between two vectors (x and y) and returns a vector z s.t. z[i] = x[i] - y[i] for all i = 0, ..., n-1 where n = min(x.size(), y.size(). Template parameters, T, can by any type for which the operator- is defined.</p>
<p>The element-wise difference is performed recursively, i.e. if the i-th element of x and the i-th element of y are std::vector, operator- calls itself to perform the element-wise difference between x[i] and y[i].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector with n elements, storing the element-wise difference between x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l00386">386</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="ga8b14f28bd4c6544e7af363162827a3f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8b14f28bd4c6544e7af363162827a3f9">&#9670;&nbsp;</a></span>operator-() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator- for std::vector.</p>
<p>Perform the element-wise difference between a vector (x) and a constant (y), and returns a vector (z) s.t. z[i] = x[i] - y for all i = 0, ..., n-1 where n = x.size(). Template parameters, T, can by any type for which the operator- is defined.</p>
<p>The element-wise difference is performed recursively, i.e. if the i-th element of x and y are std::vector, operator- calls itself to perform the element-wise difference between x[i] and y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector with n elements, storing the element-wise difference between x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l00426">426</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="ga458d5cb02f35f9a5d5bb4ec188ff7df9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga458d5cb02f35f9a5d5bb4ec188ff7df9">&#9670;&nbsp;</a></span>operator-() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d, size_t e&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;std::array&lt;T, e&gt;, d&gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator- for std::array.</p>
<p>Perform the element-wise difference between a constant (y) and a array of arrays (y), and returns z s.t. z[i][j] = x - y[i][j] for all j = 0, ..., e-1, i = 0, ..., d-1 where d = y.size(). Template parameters, T, can by any type for which the operator- is defined.</p>
<p>The element-wise difference is performed recursively, i.e. if y[i][j] and y are std::array, operator- calls itself to perform the element-wise difference between y[i][j] and x.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array of arrays having the same dimensions of y and storing the element-wise difference between x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l00501">501</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="ga579c90a19cace79621439edbc2d4a73b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga579c90a19cace79621439edbc2d4a73b">&#9670;&nbsp;</a></span>operator-() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;T, d&gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; T, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator- for std::array.</p>
<p>Perform the element-wise difference between a constant (x), and a array (y) and returns a array (z) s.t. z[i] = x - y[i] for all i = 0, ..., d-1 where d = y.size(). Template parameters, T, can by any type for which the operator- is defined.</p>
<p>The element-wise difference is performed recursively, i.e. if the i-th element of y and x are std::array, operator- calls itself to perform the element-wise difference between x[i] and y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array with d elements, storing the element-wise difference between x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l00463">463</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="gacd869d6ee14d5683b3fa4fcefc5ae5fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd869d6ee14d5683b3fa4fcefc5ae5fa">&#9670;&nbsp;</a></span>operator-() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; T &gt; &gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator- for std::vector.</p>
<p>Perform the element-wise difference between a constant (y) and a vector of vectors (y), and returns z s.t. z[i][j] = x - y[i][j] for all j = 0, ..., y[i].size()-1, i = 0, ..., n-1 where n = y.size(). Template parameters, T, can by any type for which the operator- is defined.</p>
<p>The element-wise difference is performed recursively, i.e. if y[i][j] and y are std::vector, operator- calls itself to perform the element-wise difference between y[i][j] and x.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of vectors having the same dimensions of y and storing the element-wise difference between x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l00504">504</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="ga81916c6a47f24b1ec5bfb890a7e71d93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga81916c6a47f24b1ec5bfb890a7e71d93">&#9670;&nbsp;</a></span>operator-() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator- for std::vector.</p>
<p>Perform the element-wise difference between a constant (x), and a vector (y) and returns a vector (z) s.t. z[i] = x - y[i] for all i = 0, ..., n-1 where n = y.size(). Template parameters, T, can by any type for which the operator- is defined.</p>
<p>The element-wise difference is performed recursively, i.e. if the i-th element of y and x are std::vector, operator- calls itself to perform the element-wise difference between x[i] and y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector with n elements, storing the element-wise difference between x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l00466">466</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="gaea724ee1533cefef0eeb081a124145f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaea724ee1533cefef0eeb081a124145f2">&#9670;&nbsp;</a></span>operator-=() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d, size_t e&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; std::array&lt; T, e &gt;, d &gt;&amp; operator-= </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator-= for std::array.</p>
<p>Decrement each element in the input array, using the value on the r.h.s. as negative increment, i.e.: x[i][j] -= y for all j = 0, ..., e-1, i = 0, ..., d-1 Template parameters, T, can by any type for which the operator-= is defined.</p>
<p>The element-wise decrement is performed recursively, i.e. if x[i][j] and y are std::array, operator-= calls itself to decrement x[i][j][k] by y[k], k = 0, ... , x.size()-1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first argument decremented with r.h.s. values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l00674">674</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="gae07c4511ff8846e22d929bdefc82cd46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae07c4511ff8846e22d929bdefc82cd46">&#9670;&nbsp;</a></span>operator-=() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; T, d &gt;&amp; operator-= </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; T, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; T, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator-= for std::array.</p>
<p>Decrement each element in the input array, using the corresping value on the array at the r.h.s. as negative increment, i.e.: x[i] -= y[i] for all i = 0, ..., d-1 Template parameters, T, can by any type for which the operator-= is defined.</p>
<p>The element-wise decrement is performed recursively, i.e. if the i-th element of x and the i-th element of y are std::array, operator-= calls itself to decrement x[i][j] by y[i][j], j = 0, ..., x[i].size()-1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first argument decremented with r.h.s. values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l00579">579</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="ga98e0e282c16ff506763346bbabbb27a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga98e0e282c16ff506763346bbabbb27a2">&#9670;&nbsp;</a></span>operator-=() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; T, d &gt;&amp; operator-= </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; T, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator-= for std::array.</p>
<p>Decrement each element in the input array, using the value on the r.h.s. as negative increment, i.e.: x[i] -= y for all i = 0, ..., d-1 Template parameters, T, can by any type for which the operator-= is defined.</p>
<p>The element-wise decrement is performed recursively, i.e. if the i-th element of x and y are std::array, operator-= calls itself to decrement x[i][j] by y[j], j = 0, ... , x[i].size()-1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first argument decremented with r.h.s. values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l00617">617</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="ga8734f21e1ba10ab0e30ca2d98ac458c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8734f21e1ba10ab0e30ca2d98ac458c7">&#9670;&nbsp;</a></span>operator-=() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; T &gt; &gt;&amp; operator-= </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator-= for std::vector.</p>
<p>Decrement each element in the input vector, using the value on the r.h.s. as negative increment, i.e.: x[i][j] -= y for all j = 0, ..., x[i].size()-1, i = 0, ..., n-1 where n = x.size(). Template parameters, T, can by any type for which the operator-= is defined.</p>
<p>The element-wise decrement is performed recursively, i.e. if x[i][j] and y are std::vector, operator-= calls itself to decrement x[i][j][k] by y[k], k = 0, ... , min(x[i][j].size(), y.size())-1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first argument decremented with r.h.s. values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l00662">662</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="ga0aacb9fe943aadde419e168ee051f35f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0aacb9fe943aadde419e168ee051f35f">&#9670;&nbsp;</a></span>operator-=() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt;&amp; operator-= </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator-= for std::vector.</p>
<p>Decrement each element in the input vector, using the corresping value on vector at the r.h.s. as negative increment, i.e.: x[i] -= y[i] for all i = 0, ..., n-1 where n = min(x.size(), y.size(). Template parameters, T, can by any type for which the operator-= is defined.</p>
<p>The element-wise decrement is performed recursively, i.e. if the i-th element of x and the i-th element of y are std::vector, operator-= calls itself to decrement x[i][j] by y[i][j], j = 0, ..., min(x[i].size(), y[i].size())-1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first argument decremented with r.h.s. values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l00584">584</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="gac2595b252e76781008f28f0d4259abd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac2595b252e76781008f28f0d4259abd6">&#9670;&nbsp;</a></span>operator-=() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt;&amp; operator-= </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator-= for std::vector.</p>
<p>Decrement each element in the input vector, using the value on the r.h.s. as negative increment, i.e.: x[i] -= y for all i = 0, ..., n-1 where n = x.size(). Template parameters, T, can by any type for which the operator-= is defined.</p>
<p>The element-wise decrement is performed recursively, i.e. if the i-th element of x and y are std::vector, operator-= calls itself to decrement x[i][j] by y[j], j = 0, ... , min(x[i].size(), y.size())-1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first argument decremented with r.h.s. values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l00623">623</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="gabb62dde4f70707cef0988601e7ae3c08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabb62dde4f70707cef0988601e7ae3c08">&#9670;&nbsp;</a></span>operator/() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d, size_t e&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;std::array&lt;T, e&gt;, d&gt; operator/ </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator/ for std::array.</p>
<p>Perform the element-wise division between a array of arrays (x) and a constant (y), and returns z s.t. z[i][j] = x[i][j] / y for all j = 0, ..., e-1, i = 0, ..., d-1 where d = x.size(). Template parameters, T, can by any type for which the operator/ is defined.</p>
<p>The element-wise division is performed recursively, i.e. if x[i][j] and y are std::array, operator/ calls itself to perform the element-wise division between x[i][j] and y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array of arrays having the same dimensions of x and storing the element-wise division between x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l01191">1191</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="gaf48b3511fe629a19ad6d343b3722b18f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf48b3511fe629a19ad6d343b3722b18f">&#9670;&nbsp;</a></span>operator/() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;T, d&gt; operator/ </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; T, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; T, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator/ for std::array.</p>
<p>Perform the element-wise division between two arrays (x and y) and returns a array z s.t. z[i] = x[i] / y[i] for all i = 0, ..., d-1 where d = min(x.size(), y.size(). Template parameters, T, can by any type for which the operator/ is defined.</p>
<p>The element-wise division is performed recursively, i.e. if the i-th element of x and the i-th element of y are std::array, operator/ calls itself to perform the element-wise division between x[i] and y[i].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array with d elements, storing the element-wise division between x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l01028">1028</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="ga5d819f94a4f2c54f683086dfd60914fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5d819f94a4f2c54f683086dfd60914fe">&#9670;&nbsp;</a></span>operator/() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;T, d&gt; operator/ </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; T, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator/ for std::array.</p>
<p>Perform the element-wise division between a array (x) and a constant (y), and returns a array (z) s.t. z[i] = x[i] / y for all i = 0, ..., d-1 where d = x.size(). Template parameters, T, can by any type for which the operator/ is defined.</p>
<p>The element-wise division is performed recursively, i.e. if the i-th element of x and y are std::array, operator/ calls itself to perform the element-wise division between x[i] and y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array with d elements, storing the element-wise division between x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l01067">1067</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="gab73845b94584f17c7e810e27cba36f5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab73845b94584f17c7e810e27cba36f5d">&#9670;&nbsp;</a></span>operator/() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; T &gt; &gt; operator/ </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator/ for std::vector.</p>
<p>Perform the element-wise division between a vector of vectors (x) and a constant (y), and returns z s.t. z[i][j] = x[i][j] / y for all j = 0, ..., x[i].size()-1, i = 0, ..., n-1 where n = x.size(). Template parameters, T, can by any type for which the operator/ is defined.</p>
<p>The element-wise division is performed recursively, i.e. if x[i][j] and y are std::vector, operator/ calls itself to perform the element-wise division between x[i][j] and y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of vectors having the same dimensions of x and storing the element-wise division between x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l01187">1187</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="ga4d9d274530965b0fb1a331706535b2b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4d9d274530965b0fb1a331706535b2b0">&#9670;&nbsp;</a></span>operator/() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; operator/ </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator/ for std::vector.</p>
<p>Perform the element-wise division between two vectors (x and y) and returns a vector z s.t. z[i] = x[i] / y[i] for all i = 0, ..., n-1 where n = min(x.size(), y.size(). Template parameters, T, can by any type for which the operator/ is defined.</p>
<p>The element-wise division is performed recursively, i.e. if the i-th element of x and the i-th element of y are std::vector, operator/ calls itself to perform the element-wise division between x[i] and y[i].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector with n elements, storing the element-wise division between x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l01020">1020</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="ga9ee9c85d60d975df735a1c35fcf02e20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ee9c85d60d975df735a1c35fcf02e20">&#9670;&nbsp;</a></span>operator/() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; operator/ </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator/ for std::vector.</p>
<p>Perform the element-wise division between a vector (x) and a constant (y), and returns a vector (z) s.t. z[i] = x[i] / y for all i = 0, ..., n-1 where n = x.size(). Template parameters, T, can by any type for which the operator/ is defined.</p>
<p>The element-wise division is performed recursively, i.e. if the i-th element of x and y are std::vector, operator/ calls itself to perform the element-wise division between x[i] and y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector with n elements, storing the element-wise division between x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l01060">1060</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="gaa5db31c5d90112637e4d2fa84eee9d7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa5db31c5d90112637e4d2fa84eee9d7e">&#9670;&nbsp;</a></span>operator/() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d, size_t e&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;std::array&lt;T, e&gt;, d&gt; operator/ </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator/ for std::array.</p>
<p>Perform the element-wise division between a constant (y) and a array of arrays (y), and returns z s.t. z[i][j] = x / y[i][j] for all j = 0, ..., e-1, i = 0, ..., d-1 where d = y.size(). Template parameters, T, can by any type for which the operator/ is defined.</p>
<p>The element-wise division is performed recursively, i.e. if y[i][j] and y are std::array, operator/ calls itself to perform the element-wise division between y[i][j] and x.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array of arrays having the same dimensions of y and storing the element-wise division between x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l01151">1151</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="ga17f1060376be7df1fdfaf5372216bb03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga17f1060376be7df1fdfaf5372216bb03">&#9670;&nbsp;</a></span>operator/() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;T, d&gt; operator/ </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; T, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator/ for std::array.</p>
<p>Perform the element-wise division between a constant (x), and a array (y) and returns a array (z) s.t. z[i] = x / y[i] for all i = 0, ..., d-1 where d = y.size(). Template parameters, T, can by any type for which the operator/ is defined.</p>
<p>The element-wise division is performed recursively, i.e. if the i-th element of y and x are std::array, operator/ calls itself to perform the element-wise division between x[i] and y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array with d elements, storing the element-wise division between x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l01111">1111</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="gaaa8866a1e9873585704acfa8169ba1f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaa8866a1e9873585704acfa8169ba1f4">&#9670;&nbsp;</a></span>operator/() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; T &gt; &gt; operator/ </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator/ for std::vector.</p>
<p>Perform the element-wise division between a constant (y) and a vector of vectors (y), and returns z s.t. z[i][j] = x / y[i][j] for all j = 0, ..., y[i].size()-1, i = 0, ..., n-1 where n = y.size(). Template parameters, T, can by any type for which the operator/ is defined.</p>
<p>The element-wise division is performed recursively, i.e. if y[i][j] and y are std::vector, operator/ calls itself to perform the element-wise division between y[i][j] and x.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of vectors having the same dimensions of y and storing the element-wise division between x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l01146">1146</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="gac6fff4de3b1f6cbedc8b80e0f29b673f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac6fff4de3b1f6cbedc8b80e0f29b673f">&#9670;&nbsp;</a></span>operator/() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; operator/ </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator/ for std::vector.</p>
<p>Perform the element-wise division between a constant (x), and a vector (y) and returns a vector (z) s.t. z[i] = x / y[i] for all i = 0, ..., n-1 where n = y.size(). Template parameters, T, can by any type for which the operator/ is defined.</p>
<p>The element-wise division is performed recursively, i.e. if the i-th element of y and x are std::vector, operator/ calls itself to perform the element-wise division between x[i] and y.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector with n elements, storing the element-wise division between x and y. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l01105">1105</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="ga50403f99e949516bedf459d21540353c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga50403f99e949516bedf459d21540353c">&#9670;&nbsp;</a></span>operator/=() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d, size_t e&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; std::array&lt; T, e &gt;, d &gt;&amp; operator/= </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; std::array&lt; T, e &gt;, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator/= for std::array.</p>
<p>Increment each element in the input array, using the value on the r.h.s. as increment, i.e.: x[i][j] /= y for all j = 0, ..., e-1, i = 0, ..., d-1 Template parameters, T, can by any type for which the operator/= is defined.</p>
<p>The element-wise increment is performed recursively, i.e. if x[i][j] and y are std::array, operator/= calls itself to increment x[i][j][k] by y[k], k = 0, ... , x.size()-1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first argument incremented with r.h.s. values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l01291">1291</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="ga86745bdc619c80a87b7495a2be35b5be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga86745bdc619c80a87b7495a2be35b5be">&#9670;&nbsp;</a></span>operator/=() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; T, d &gt;&amp; operator/= </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; T, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; T, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator/= for std::array.</p>
<p>Increment each element in the input array, using the corresping value on array at the r.h.s. as increment, i.e.: x[i] /= y[i] for all i = 0, ..., d-1 Template parameters, T, can by any type for which the operator/= is defined.</p>
<p>The element-wise increment is performed recursively, i.e. if the i-th element of x and the i-th element of y are std::array, operator/= calls itself to increment x[i][j] by y[i][j], j = 0, ..., x[i].size()-1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first argument incremented with r.h.s. values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l01231">1231</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="ga5b7c612383329df772db1f49839fea19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5b7c612383329df772db1f49839fea19">&#9670;&nbsp;</a></span>operator/=() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , size_t d&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; T, d &gt;&amp; operator/= </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; T, d &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator/= for std::array.</p>
<p>Increment each element in the input array, using the value on the r.h.s. as increment, i.e.: x[i] /= y for all i = 0, ..., d-1 Template parameters, T, can by any type for which the operator/= is defined.</p>
<p>The element-wise increment is performed recursively, i.e. if the i-th element of x and y are std::array, operator/= calls itself to increment x[i][j] by y[j], j = 0, ... , x[i].size()-1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first argument incremented with r.h.s. values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__array_8tpp_source.html#l01261">1261</a> of file <a class="el" href="Operators__array_8tpp_source.html">Operators_array.tpp</a>.</p>

</div>
</div>
<a id="ga661186ca419d7b771ea549dc2bee4229"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga661186ca419d7b771ea549dc2bee4229">&#9670;&nbsp;</a></span>operator/=() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; T &gt; &gt;&amp; operator/= </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator/= for std::vector.</p>
<p>Increment each element in the input vector, using the value on the r.h.s. as increment, i.e.: x[i][j] /= y for all j = 0, ..., x[i].size()-1, i = 0, ..., n-1 where n = x.size(). Template parameters, T, can by any type for which the operator/= is defined.</p>
<p>The element-wise increment is performed recursively, i.e. if x[i][j] and y are std::vector, operator/= calls itself to increment x[i][j][k] by y[k], k = 0, ... , min(x[i][j].size(), y.size())-1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first argument incremented with r.h.s. values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l01307">1307</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="gabef2e8a23bc01ea9a02f8478705a8055"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabef2e8a23bc01ea9a02f8478705a8055">&#9670;&nbsp;</a></span>operator/=() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt;&amp; operator/= </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator/= for std::vector.</p>
<p>Increment each element in the input vector, using the corresping value on vector at the r.h.s. as increment, i.e.: x[i] /= y[i] for all i = 0, ..., n-1 where n = min(x.size(), y.size(). Template parameters, T, can by any type for which the operator/= is defined.</p>
<p>The element-wise increment is performed recursively, i.e. if the i-th element of x and the i-th element of y are std::vector, operator/= calls itself to increment x[i][j] by y[i][j], j = 0, ..., min(x[i].size(), y[i].size())-1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first argument incremented with r.h.s. values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l01229">1229</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
<a id="gad1c760c866b18096f41015d84c1ba517"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad1c760c866b18096f41015d84c1ba517">&#9670;&nbsp;</a></span>operator/=() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt;&amp; operator/= </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operator/= for std::vector.</p>
<p>Increment each element in the input vector, using the value on the r.h.s. as increment, i.e.: x[i] /= y for all i = 0, ..., n-1 where n = x.size(). Template parameters, T, can by any type for which the operator/= is defined.</p>
<p>The element-wise increment is performed recursively, i.e. if the i-th element of x and y are std::vector, operator/= calls itself to increment x[i][j] by y[j], j = 0, ... , min(x[i].size(), y.size())-1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>first argument incremented with r.h.s. values. </dd></dl>

<p class="definition">Definition at line <a class="el" href="Operators__vector_8tpp_source.html#l01268">1268</a> of file <a class="el" href="Operators__vector_8tpp_source.html">Operators_vector.tpp</a>.</p>

</div>
</div>
</div><!-- contents -->
---
layout: doxygen_footer
---
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<address class="footer"><small>
Generated on Mon Mar 29 2021 21:17:48 for bitpit by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.9.1
</small></address>
